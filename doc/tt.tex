\documentclass[11pt]{article}

\usepackage{times}
\usepackage{mathpartir}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{xcolor}

%%%%%% Macros here %%%%%%

%% Syntax
\newcommand{\bnf}{\ \mathrel{{:}{:}{=}}\ }
\newcommand{\bnfor}{\ \mid\ \ }

\newcommand{\x}{x}     % brazil variable
\newcommand{\y}{y}     % another variable
\newcommand{\z}{z}     % another variable
\newcommand{\C}{C}     % computation
\newcommand{\K}{K}     % continuation variable
\newcommand{\X}{X}     % TT (computation) variable
\newcommand{\e}{e}     % expression
\newcommand{\rgn}{r}   % region
\newcommand{\h}{h}     % handler
\newcommand{\T}{T}     % type
\newcommand{\U}{U}     % another type

\newcommand{\val}{\mathsf{val}\,} % val e
\newcommand{\letin}[1]{\mathsf{let}\; #1 \;\mathsf{in}\;} % let x = c1 in c2
\newcommand{\op}[3]{\mathsf{op}_{#1}(#2, #3)} % operation
\newcommand{\inhabitPat}[2]{\mathsf{inhabit}(#1, #2)} % the inhabit pattern
\newcommand{\inhabit}[3]{\mathsf{inhabit}(#1, #2, #3)} % the inhabit operation
\newcommand{\withhandle}[1]{\mathsf{with}\;#1\;\mathsf{handle}\;} % handle
\newcommand{\abs}[1]{\mathsf{abs}\;#1\;\mathsf{in}\;} % abstraction
\newcommand{\new}[2]{\mathsf{new}(#1,#2)} % new(r,T)
\newcommand{\fun}[1]{\mathsf{fun}\;#1\Rightarrow} % tt-level function
\newcommand{\app}[2]{#1\,#2} % application
\newcommand{\lam}[2]{\lambda #1 \,{:}\, #2 \,.\,} % Kind of Brazilian lambda
\newcommand{\kapp}[2]{#1[#2]} % continuation application

\newcommand{\handler}[5]{\mathsf{handler}\; \val #1 \mapsto #2 \mid \inhabitPat{#3}{#4} \mapsto #5}

\newcommand{\makeApp}[2]{\mathsf{app}(#1,#2)} % introduce a Brazil application

\newcommand{\debruijn}[1]{\mathsf{debruijn}\,#1} % ugly hack

\newcommand{\subst}[3]{#1[#3/#2]} % substitution
\newcommand{\substs}[2]{#1[#2]} % substitution of many things

\newcommand{\cont}{{\cal K}}     % continuation
\newcommand{\hole}{\bullet}

%%% Operational semantics

\newcommand{\emptyG}{\bullet} % empty context
\newcommand{\emptyH}{\circ} % empty handlers

\newcommand{\G}{\Gamma}
\newcommand{\D}{\Delta}
\newcommand{\xcT}{\vec{\x}{:}\vec{\T}}
\newcommand{\xT}{{\vec{\x}}{\vec{\T}}}
\renewcommand{\H}{\mathcal{H}} % A stack of handlers
\newcommand{\GH}{\G, \H} % combined context & handler

\newcommand{\ctxextend}[3][\G]{#1, #2 {:} #3}

\newcommand{\evalto}[3][\G]{#1 \vdash #2 \ \Downarrow\  #3}

\newcommand{\resultok}[2][\G]{#1 \vdash #2 \ \mathsf{ok}}
\newcommand{\eok}[2][\G]{#1 \vdash #2 \ \ \mathsf{ok}}
\newcommand{\cok}[2][\G]{#1 \vdash #2 \ \ \mathsf{ok}}
\newcommand{\kok}[2][\G]{#1 \vdash #2 \ \ \mathsf{ok}}

\newcommand{\istype}[2]{#1 \vdash #2\;\mathsf{type}} % well formed type
\newcommand{\isterm}[3]{#1 \vdash\,#2\,:\,#3} % well formed term


\newcommand{\typicalhandler}{\handler{\X}{\C_1}{\X}{\K}{\C_2}}

\begin{document}

\title{TT}
\author{Andrej Bauer \and Matija Pretnar \and Christopher A. Stone}
\maketitle

\section{Abstract syntax}
\label{sec:abstract-syntax}

\begin{equation*}
  \text{Expression $\e$}
  \begin{aligned}[t]
    &\bnf   {} && \X          && \text{variable} \\
    &\bnfor {} && \fun{\X} \C  && \text{function} \\
    &\bnfor {} && h           && \text{handler} \\
    &\bnfor {} && B           && \text{Brazilian term} \\
    &\bnfor {} && T           && \text{Brazilian type} \\
  \end{aligned}
\end{equation*}
%
\begin{equation*}
  \text{Computation $\C$}
  \begin{aligned}[t]
    &\bnf   {} && \val \e                && \text{pure expression} \\
    &\bnfor {} && \app{\e_1}{\e_2}   && \text{application} \\
    &\bnfor {} && \letin{\X = \C_1} \C_2  && \text{$\mathsf{let}$-binding} \\
    &\bnfor {} && \inhabit{\D}{\e}{\cont} && \text{the inhabitation operation} \\
    &\bnfor {} && \debruijn{n} && \text{ugly hack to be deleted later} \\
    &\bnfor {} && \withhandle{\e} \C && \text{handling} \\
%    &\bnfor {} && \abs{\rgn}{\C} && \text{abstraction} \\
%    &\bnfor {} && \new{\rgn}{\T} && \text{new variable} \\
    &\bnfor {} && \kapp{\K}{\e_2}   && \text{Invoke a continuation variable} \\
    &\bnfor {} && \lam{\x}{\e} \C   && \text{Build Brazilian abstraction} \\
    &\bnfor {} && \makeApp{\e_1}{\e_2} && \text{Build Brazilian application} \\
  \end{aligned}
\end{equation*}
%
\begin{equation*}
  \text{(Capturing!) Continuation $\cont$}
  \begin{aligned}[t]
    &\bnf   {} && \hole                && \text{hole} \\
    &\bnfor {} && \letin{\X = \cont_1} \C_2  && \text{$\mathsf{let}$-binding} \\
    &\bnfor {} && \withhandle{\e} \cont && \text{handling} \\
%    &\bnfor {} && \abs{\rgn}{\cont} && \text{abstraction} \\
    &\bnfor {} && \lam{\x}{\T} \cont   && \text{$\lambda$-abstraction} \\
  \end{aligned}
\end{equation*}

%
\begin{equation*}
  \text{Handler $\h$}
  \bnf (\typicalhandler)\\
\end{equation*}



\section{Operational semantics}
\label{sec:oper-semant}

Results:
%
\begin{equation*}
  \text{Result $R$}
  \begin{aligned}[t]
    &\bnf   {} && \val \e \\
    &\bnfor {} && \inhabit{\D}{\e}{\cont} \\
  \end{aligned}
\end{equation*}
%
Judgement:
%
\begin{align*}
  &\evalto[\G]{C}{e} &&\text{$C$ evaluates to $e$ in context $\G$} \\
  &\resultok[\G]{R}  &&\text{$R$ is a valid result in context $\G$}
\end{align*}
%
Rules:
\begin{mathpar}

  \infer[eval-val]
  { }
  { \evalto{\val \e}{\val \e}}

  \infer[eval-app]
  {
    \evalto{\subst{\C}{\x}{\e}}{R}
  }
  { \evalto
    {\app{(\fun{\x}{\C})}{\e}}
    {R}
  }

  \infer[eval-let-val]
  {
    \evalto{\C_1}{\val \e}
    \\
    \evalto{\subst{\C_2}{\X}{\e}}{R}
  }
  { \evalto
    {\letin{\X = \C_1} \C_2}
    {R}
  }

  \infer[eval-let-op]
  {
    \evalto
    {\C_1}
    {\inhabit{\D}{\e}{\cont}}
  }
  { \evalto
    {\letin{\X = \C_1} \C_2}
    {\inhabit{\D}{\e}{\letin{\X = \cont} \C_2}}
  }

  \infer[eval-handle-val]
  {
    \evalto{\C}{\val \e}
    \\
    \evalto{\subst{\C_1}{\x}{\e}}{R}
  }
  { \evalto
    {\withhandle{(\typicalhandler)}{\C}}
    {R}
  }

  \infer[eval-handle-op]
  {
    \evalto{\C}{\inhabit{\D}{\e}{\cont}}
    \\\\
    \evalto[\G,\D]
    {\substs{\C_2}{\e/\X, (\withhandle{h}{\cont})/\K}}
    {R}
    \\\\
    \resultok{R}\\
  }
  { \evalto
    {\withhandle{(\typicalhandler)}{\C}}
    {R}
  }

  \infer[eval-lambda-val]
  {
    \evalto[\ctxextend{\x}{\T}]
    {\C}
    {\val B}
  }
  { \evalto
    {\lam{\x}{\T} \C}
    {\val (\lam{\x}{\T} B)}
  }

  \infer[eval-lambda-op]
  {
    \evalto[\ctxextend{\x}{\T}]
    {\C}
    {\inhabit{\D}{\e}{\cont}}
  }
  { \evalto
    {\lam{\x}{\T} \C}
    {\inhabit{(\x{:}\T,\Delta)}{\e}{\lam{\x}{\T}{\cont}}}
  }
\end{mathpar}

\section{Well-Formedness}

\subsection*{Expressions}

\begin{mathpar}

  \infer[ok-brazil-term]
  {
    \isterm{\G}{B}{\T}
  }
  {
    \eok{B}
  }


  \infer[ok-brazil-type]
  {
    \istype{\G}{\T}
  }
  {
    \eok{B}
  }

  \infer[ok-var]
  {
  }
  {
    \eok{\X}
  }

  \infer[ok-fun]
  {
    \cok{\C}
  }
  {
    \eok{\fun{\X} \C}
  }

  \infer[ok-handler]
  {
    \cok{\C_1} \\
    \cok{\C_2} \\
  }
  {
    \eok{(\typicalhandler)}
  }
\end{mathpar}

\subsection*{Continuations}

\begin{mathpar}

  \infer[ok-hole]
  {
  }
  {
    \kok{\hole}
  }

  \infer[ok-let-cont]
  {
    \kok{\K_1} \\
    \cok{\C_2} \\
  }
  {
    \kok{(\letin{\X = \K_1} \C_2)}
  }

  \\

  \infer[ok-handle-cont]
  {
    \eok{\e_1} \\
    \kok{\K_2} \\
  }
  {
    \kok{(\withhandle{\e_1} \K_2)}
  }

  \infer[ok-lam-cont]
  {
    \kok[\ctxextend{\x}{\T_1}]{\K_2}
  }
  {
    \kok{(\lam{\x}{\T_1} \K_2)}
  }
\end{mathpar}

\subsection*{Computations (and results)}

\begin{mathpar}

  \infer[ok-val]
  {
    \eok{\e}
  }
  {
    \cok{\val{\e}}
  }

  \infer[ok-app]
  {
    \eok{\e_1} \\
    \eok{\e_2} \\
  }
  {
    \cok{\app{\e_1}{\e_2}}
  }

  \infer[ok-let]
  {
    \cok{\C_1} \\
    \cok{\C_2} \\
  }
  {
    \cok{(\letin{\X = \C_1} \C_2)}
  }

  \infer[ok-inhabit]
  {
    \eok[\G,\D]{\e} \\
    \kok{\K} \\
  }
  {
    \cok{\inhabit{\D}{\e}{\K}}
  }

  \infer[ok-hack]
  {
  }
  {
    \cok{(\debruijn{n})}
  }

  \infer[ok-handle]
  {
    \eok{\e_1} \\
    \cok{\C_1} \\
  }
  {
    \cok{(\withhandle{\e_1} \C_2)}
  }

  \infer[ok-cont-app]
  {
    \eok{\e_2}
  }
  {
    \cok{\kapp{\K_1}{\e_2}}
  }

  \\

  \infer[ok-make-lam]
  {
    \cok{\C_2}
  }
  {
    \cok{(\lam{\x}{\e_1} \C_2)}
  }

  \infer[ok-make-app]
  {
    \eok{\e_1} \\
    \eok{\e_2} \\
  }
  {
    \cok{\makeApp{\e_1}{\e_2}}
  }

\end{mathpar}



\end{document}
