% Universe indices

\newcommand{\NN}{\mathbb{N}} % God-given numbers

% Generic entities
\newcommand{\G}{\Gamma} % a context
\newcommand{\D}{\Delta} % another context
\newcommand{\T}{T} % a type
\newcommand{\U}{U} % another type
\newcommand{\x}{x} % a term variable
\newcommand{\y}{y} % another term variable
\newcommand{\z}{z} % a third term variable
\newcommand{\e}{e} % a term
\newcommand{\cmd}{C} % a command
\newcommand{\expr}{E} % an expressions

\newcommand{\rulename}[1]{\text{\textsc{#1}}}

%% Syntax
\newcommand{\bnf}{\ \mathrel{{:}{:}{=}}\ }
\newcommand{\bnfor}{\ \mid\ \ }

%% Syntactic constructs
\newcommand{\ctxempty}{\bullet} % empty context
\newcommand{\ctxextend}[3]{#1,\, #2\, {:}\, #3} % extended context

\newcommand{\subst}[3]{#1[#3/#2]} % substitution
\newcommand{\substs}[2]{#1[#2]} % substitution of many variables

\newcommand{\Type}{\mathsf{Type}} % The type of all types

% "raw" versions of \Prod, \lam and \app
\newcommand{\xProd}[1]{\mathop{\textstyle\prod_{#1}}}
\newcommand{\xlam}[2]{\lambda #1.#2\,.\,}
\newcommand{\xapp}[3]{#1\mathbin{@^{#2}} #3}

% classic versions of \Prod, \lam and \app
\newcommand{\cProd}[2]{\xProd{(#1 {:} #2)}}
\newcommand{\clam}[3]{\xlam{#1 {:} #2}{#3}}
\newcommand{\capp}[5]{\xapp{#1}{#2{:}#3.#4}{#5}}

% spine versions of \Prod, \lam and \app
\newcommand{\many}[1]{\overrightharpoon{#1}}
\newcommand{\sProd}[2]{\xProd{(\many{#1{:}#2})}}
\newcommand{\slam}[3]{\xlam{(\many{#1{:}#2})}{#3}}
\newcommand{\sapp}[5]{\xapp{#1}{(\many{#2{:}#3}).#4}{\many{#5}}}

\newcommand{\abst}[2]{[#1 \,.\, #2]} % abstraction
\newcommand{\ascribe}[2]{#1 \,{:}{:}\, #2} % type ascription

\newcommand{\Equal}[3]{\mathsf{Eq}_{#1}(#2,#3)} % Equality type
\newcommand{\refl}[1]{{\mathsf{refl}_{#1}}\ }   % reflexivity

% orthodox judgments
\newcommand{\isctx}[1]{#1\ \mathsf{ctx}} % well formed context
\newcommand{\istype}[2]{#1 \vdash\, #2 \ \mathsf{type}} % well formed type
\newcommand{\isterm}[3]{#1 \vdash\,#2\,:\,#3} % well formed term

\newcommand{\eqtype}[3]{#1 \vdash #2 \equiv #3 \ \mathsf{type}} % equal types
\newcommand{\eqterm}[4]{#1 \vdash #2 \equiv #3 : #4} % equal terms

% commands

\newcommand{\cmdLam}[2]{\lambda #1 {:} #2\,.\,} % $\lambda$-abstraction untagged return type
\newcommand{\cmdLamCurry}[1]{\lambda #1 \,.\,} % $\lambda$-abstraction completely untagged
\newcommand{\cmdApp}[2]{#1\,#2} % application untagged
\newcommand{\cmdType}{\mathsf{Type}} % The type of all types
\newcommand{\cmdProd}[2]{\mathop{\textstyle\prod_{(#1 {:} #2)}}} % dependent product
\newcommand{\cmdAscribe}[2]{#1 \,{:}{:}\, #2} % type ascription
\newcommand{\cmdLet}[2]{\mathsf{let}\;#1 \mathbin{{:}{=}} #2\; \mathsf{in}\;} % let-binding
\newcommand{\cmdEq}[2]{\mathsf{Eq}(#1,#2)} % Equality type
\newcommand{\cmdRefl}{\mathsf{refl}\;}    % Judgmental refl
\newcommand{\cmdReturn}{\mathsf{return}\;}    % Judgmental refl


% algorithmic judgments
\newcommand{\env}{\eta}
\newcommand{\envextend}[4]{#1(#2) \mathbin{{:}{=}} (#3, #4)} % extended context
\newcommand{\ctxenv}{\G;\, \env} % A combined context and environment

\newcommand{\evalc}[4]{#1 \vdash #2 \Leftarrow #3 \mapsto #4} % checking
\newcommand{\evali}[4]{#1 \vdash #2 \Rightarrow (#3, #4)} % inference

\newcommand{\ishints}[2]{#1 \vdash #2 \; \mathsf{hints}} % well-formed context and hints

\newcommand{\istypealg}[2]{#1 \vdash #2 \Leftarrow \mathsf{type}} % well formed type
\newcommand{\isfibalg}[2]{#1 \vdash #2 \Leftarrow \mathsf{fibered}} % is a fibered type
\newcommand{\eqtypealg}[3]{#1 \vdash #2 \thickapprox #3} % equal types
\newcommand{\eqtypepath}[3]{#1 \vdash #2 \thicksim #3} % equal normal-form types
\newcommand{\eqtermalg}[4]{#1 \vdash #2 \thickapprox #3 \Leftarrow #4} % equal terms of normalized type
\newcommand{\eqtermext}[4]{#1 \vdash #2 \simeq #3 \Leftarrow #4} % equal terms w/o eta
\newcommand{\eqpath}[4]{#1 \vdash #2 \thicksim #3}  % equal paths

\newcommand{\equationin}[3]{\mathsf{equation}\; #1 \,{:}\, #2 \,{\equiv}\, #3 \; \mathsf{in} \;} % use equation hint
\newcommand{\rewritein}[3]{\mathsf{rewrite}\; #1 \,{:}\, #2 \,{\equiv}\, #3 \; \mathsf{in} \;} % use rewrite hint
\newcommand{\eqhint}[2]{(#1 \,{\equiv}\, #2)} % equality hint
\newcommand{\rwhint}[2]{(#1 \,{\leadsto}\, #2)} % rewrite hint

\renewcommand{\H}{\mathcal{H}}      % term hint list
\newcommand{\hintempty}{\circ}      % empty hint list

\newcommand{\addhinteq}[3]{#1, \eqhint{#2}{#3}} % extended hint list
\newcommand{\addhintrw}[3]{#1, \rwhint{#2}{#3}} % extended hint list
\newcommand{\ctxs}[2]{#1\,;\,#2}
\newcommand{\GH}{\ctxs{\G}{\H}}           % combined context and hints

% normalization

\newcommand{\tywhnf}[4]{#1 \vdash #2 \leadsto #3 / #4} % "one-step type normalization"
\newcommand{\whnf}[4]{#1 \vdash #2 \leadsto #3 / #4} % "one-step term normalization"

\newcommand{\tywhnfs}[3]{#1 \vdash #2 \leadsto^* #3 \not\leadsto } % "type normalization"
\newcommand{\whnfs}[3]{#1 \vdash #2 \leadsto^* #3 \not\leadsto } % "term normalization"

\newcommand{\inferred}[1]{{\color{magenta}{#1}}}

\newcommand{\simplefib}{\mathop{\mathsf{isfib}}\,}
\newcommand{\true}{\mathsf{true}}
\newcommand{\false}{\mathsf{false}}

\newcommand{\nameof}{{\mathsf{name\_of}}\,}
\newcommand{\typeof}[2]{{\mathsf{type\_of}}(#1,#2)}

\newcommand{\tynorm}[2]{#1 \hookrightarrow #2} % (strong) normalization of terms
\newcommand{\norm}[2]{#1 \hookrightarrow #2} % (strong) normalization of terms

%%% Local Variables:
%%% mode: plain-tex
%%% TeX-master: "theory"
%%% End:
