Type theory:
  * x variable
  * Type universe
  * ∏ (x : A), B product
  * λ (x : A), e : B abstraction
  * e₁ @(x:A,B) e₂ application
  * Eq_A(e₁, e₂)  equality type
  * refl_A e

Typing rules (TODO):

[pi-form]
formation rule for ∏

[conv]
Γ ⊢ a : A
Γ ⊢ A ≡_Type B
—————————————–
Γ ⊢ a : B


Definition (TODO: make precise): A context Γ is a directed graph whose vertices are of the
form x : A and the edges are "dependencies". A context Γ is well-formed when ... (TODO).

Definition: dom(Γ) is the set of variables mentioned by Γ.

Definition: Γ ≤ Δ means that Δ is an extension of Γ (TODO: make this precise)

Definition: Γ \ y:A is Γ without y:A but is only defined if:
  * either y does not appear in Γ
  * or y:A is a leaf in Γ

Proposition weak-admissible: Weakening is admissible:
  if Γ ⊢ e : A is derivable and Γ ≤ Δ then Δ ⊢ e : A is derivable.

Definition (TODO): Define the join Γ ⋈ Δ of contexts Γ and Δ (may be undefined).
We rely on the following properties of ⋈, assuming Γ ⋈ Δ is defined:
* Γ ≤ Γ ⋈ Δ
* Δ ≤ Γ ⋈ Δ
* dom(Γ ⋈ Δ) = dom(Γ) ∪ dom(Δ)

Definition:
An environment η maps variables to judgements.
An environment η is *valid* if it maps to derivable judgements.

Computation a, b, c:
  * x
  * Type
  * ∏ (x : a), b
  * λ (x : a), c 
  * c₁ c₂
  * c₁ ≡ c₂
  * refl c
  * #equal c₁ c₂
  * TODO: put in the rest

Value v:
  * Γ ⊢ e : A

Result(α):
  * val α
  * #equal v₁ v₂ κ
    where κ : Value → Result(α)

Evaluation relation:
* inferring η | c ↦ r of type Result (Value)
* checking  η | c : (Γ ⊢ A type) ↦ r of type Result (Context × Term)

Evaluation rules (TODO: get all of them):

[eval-var]
x ∈ dom(η)
—————————–
η | x ↦ val η(x)

[eval-type]
—————————————————————–
η | Type ↦ val (⊢ Type : Type)

[eval-pi]
η | a : (⊢ Type type) ↦ val (Γ ⊢ A : _)
y is fresh for Γ
η[x:=(Γ,y:A ⊢ y:A)] | b : (⊢ Type type) ↦ val (Δ ⊢ B : _)
Ξ := Γ ⋈ (Δ \ y:A)
—————————————————————–
η | ∏ (x : a), b ↦ val (Ξ  ⊢ ∏ (y : A), B : Type)

[eval-refl]
η | c ↦ val (Γ ⊢ e : A)
————————————————————-
η | refl c ↦ val (Γ ⊢ refl_A e : Eq_A(e, e))

[eval-check-infer] (TODO: make this more precise)
η | c ↦ val (Δ ⊢ e : B)
κ := (fun (Ξ ⊢ ξ : C) ⇒
      verify C ≡≡ Eq_Type(B,A) ;
      let Ψ := Δ ⋈ Γ ⋈ Ξ in
      val (Ψ ⊢ e : _))
——————————————————————————————————
η | c : (Γ ⊢ A type) ↦ #equal (Δ ⊢ B : Type) (Γ ⊢ A : Type) κ

(* TODO for evaluation: treat operations and handlers *)

Proposition eval-sound:
  * if η is valid and  η | c ↦ (Γ ⊢ e : A) then Γ ⊢ e : A is derivable
  * if η is valid and η | c : (Γ ⊢ A type) ↦ (Δ ⊢ e : _) then
    Δ ⊢ e : A is derivable and Γ ≤ Δ

Proof: By induction on ↦

Case eval-var: η is valid

Case eval-type: by introduction rule for Type

Case eval-pi: by pi-form because
1. Ξ is a context by definition of ⋈ and \ 
2. Ξ ⊢ A type because by i.h. Γ ⊢ A type and Γ ≤ Ξ, use weakening
3. Ξ, y:A is a context because y fresh and 2.
4. Ξ, y:A ⊢ B type because by i.h. Δ ⊢ B type and Δ ≤ Ξ, y:A, use weakening:
   Δ ≤ ((Δ \ y:A), y:A) ≤ (Γ ⋈ ((Δ \ y:A), y:A)) = ((Γ ⋈ (Δ \ y:A)), y:A) = (Ξ, y:A)

Case eval-refl: by refl-intro because and i.h.

Case eval-check-infer: by conv because
1. Ψ ⊢ e : B by i.h. and Δ ≤ Ψ, use weakening
2. Ψ ⊢ B ≡_Type A by reflection:
   * Ψ ⊢ ξ : Eq_Type(B, A) by weakening and i.h.

TODO: all other cases


