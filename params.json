{"name":"Andromeda","tagline":"Type theory with equality reflection","body":"### About the project\r\n\r\nAndromeda is an experimental implementation of dependent type theory with a reflection rule.\r\nFor theoretical background see:\r\n\r\n* Andrej Bauer: \"How to implemenent type theory with a reflection rule\"\r\n  ([slides](http://www.qmac.ox.ac.uk/events/Talk%20slides/Bauer-HoTT-Oxford.pdf) and\r\n   [video](https://www.youtube.com/watch?v=IlfQjWqrK6I))\r\n\r\nThe reflection rule allows us to do many things, such as add new computation\r\nrules for new type formers, and hopefully also provide support for Vladimir\r\nVoevodsky's [Homotopy Type System](http://ncatlab.org/homotopytypetheory/show/Homotopy+Type+System)\r\nwhich has *two* kinds of equality, one of which has a reflection rule.\r\n\r\n\r\n### Installation\r\n\r\nThe easiest way to install Andromeda is through the\r\n[Opam](http://opam.ocamlpro.com) package manager for OCaml. You can install\r\nOpam on your system following [these\r\ninstructions](http://opam.ocaml.org/doc/Install.html).\r\nIn case your operating system does not provide OCaml version >= 4.02, you can\r\ninstall it with `opam switch 4.02.1`.\r\nThen simply add the Andromeda repo to opam, update and install Andromeda with\r\nthese commands:\r\n```\r\nopam repo add andromeda git://github.com/haselwarter/andromeda-opam.git\r\nopam update\r\nopam install andromeda\r\n```\r\n\r\n\r\n### Compilation\r\n\r\nTo build Andromeda, you need [OCaml 4.02](http://ocaml.org) or later (and quite possibly it\r\nworks with earlier versions too), the [menhir](http://gallium.inria.fr/~fpottier/menhir/)\r\nparser generator and the [sedlex](https://www.lexifi.com/sedlex) unicode lexer. We recommend\r\nusing [Opam](http://opam.ocamlpro.com) for installation of OCaml, menhir and sedlex.\r\n\r\nIf you also install the [ledit](http://opam.ocaml.org/packages/ledit/ledit.2.03/) or\r\n[rlwrap](http://utopia.knoware.nl/~hlub/uck/rlwrap/#rlwrap) utility, the Andromeda toplevel\r\nwill use them to give you line editing capabilities.\r\n\r\n### Building Andromeda\r\n\r\nTo build Andromeda type `make` at the command line. This will create the executable\r\n`andromeda.byte`. You can run the tests in the `test` subfolder with `make test`.\r\n\r\nThe file `prelude.m31` contains basic definitions and is loaded when Andromeda is\r\nstarted (unless the option `--no-prelude` is given).\r\n\r\n#### Examples\r\n\r\nWe have put some examples in the `examples` subdirectory. An outdated and incomplete\r\ndescription of the Andromedan type theory can be found in `doc/andromeda.tex`. We are\r\nstill changing Andromeda in every respect so it probably does not make sense to write\r\ndocumentation at this point.\r\n\r\n### The structure of source code\r\n\r\nThe source code can be found in `src`, in the following folders:\r\n\r\n* `parser` - input syntax, lexer, parser, and the desugaring phase which computes de Bruijn indices\r\n   and separates expressions and computations\r\n* `runtime` - context manipulation, runtime values and the main evaluation loop\r\n* `tt` - abstract syntax, weak-head normal forms, equality checks\r\n* `utils` - error messages, file locations, pretty printing, manipulation of variable names\r\n* `andromeda.ml` - main program\r\n* `config.ml` - configuration\r\n* `syntax.mli` - desugared input syntax\r\n\r\nThe basic steps in the evaluation of input are:\r\n\r\n1. An expression is parsed using the lexer `parser/lexer.mll` and the parser `parser/parser.mly`.\r\n   The result is a value of type `Input.term` or `Input.ty` or `Input.toplevel`. The user input\r\n   has no separation of computations (effectful) and expressions (pure).\r\n2. `Desugar` converts the parsed entity to the corresponding intermediate representation of\r\n   type `Syntax.expr`, `Syntax.comp` or `Syntax.toplevel`. Desugaring replaces named bound variables\r\n   with de Bruijn indices and separates computations from expressions.\r\n3. `Eval` evaluates the syntactic expression to a result of type `Value.result`. The result is a\r\n   pair [(e,t)] of a value [e] and its type [t]. Evaluation is done in a context [ctx] of type\r\n   [Context.t] which consists of: free variables with their types, bound variables mapped to their\r\n   values, and equality hints.\r\n\r\nThe correctness guarantee for the evaluator is this: if a computation [c] evaluates to a value [(e,t)]\r\nin context [ctx] then the judgement [ctx |- e : t] is derivable.\r\n\r\n### History of the name Andromeda\r\n\r\nAndromeda used to be called Brazil, as a consequence of discussions at the Institute for\r\nAdvanced Study where we talked about \"sending proofs to a far away place where they will\r\ncheck them independently\". We thought of Brazil as a faraway place, but it later turned\r\nout it was not quite far enough. We hope that nobody will claim that the Andromeda galaxy\r\nis a nearby place.\r\n\r\n### Travis Continuous Integration\r\n\r\nThe GitHub repository is linked to Travis CI. To find out the current build status is\r\ndisplayed here:\r\n\r\n  [![Build Status](https://api.travis-ci.org/andrejbauer/andromeda.png?branch=master)](https://travis-ci.org/andrejbauer/andromeda)\r\n","google":"UA-64364355-1","note":"Don't delete this file! It's used internally to help with page regeneration."}