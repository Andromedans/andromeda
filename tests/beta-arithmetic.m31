constant N : Type
constant Z : N
constant S : N -> N

constant plus : N -> N -> N
let _ = set_reducing plus [lazy,eager]

constant plus_Z : Π (x : N), plus x Z == x
constant plus_S : Π (x y : N), plus x (S y) == S (plus x y)

constant times : N -> N -> N
constant times_Z : Π (x : N), times x Z == Z
constant times_S : Π (x y : N), times x (S y) == plus x (times x y)

let one =   S Z
let two =   S (S Z)
let three = S (S (S Z))
let four =  S (S (S (S Z)))
let five =  S (S (S (S (S Z))))
let ten =   S (S (S (S (S (S (S (S (S (S Z)))))))))

do
  with local (lbeta plus_Z) handle
  with local (lbeta plus_S) handle
    refl (plus five four) : plus four five == plus (plus two three) four


do
  with local (lbeta plus_Z) handle
  with local (lbeta plus_S) handle
    refl three : three == plus one (plus one one)

do
  with local (lbeta plus_Z) handle
  with local (lbeta plus_S) handle
  with local (lbeta times_Z) handle
  with local (lbeta times_S) handle
    refl four : four == times two two

