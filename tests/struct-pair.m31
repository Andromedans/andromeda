
signature prod_s = { A : Type, B : Type, fst : A, snd : B }

let prod = lambda (A B : Type), {prod_s with A = A, B = B}

let pair = lambda (A B : Type) (x : A) (y : B),
  { A, B,
    fst = x,
    snd = y } : prod A B

let fst = lambda (A B : Type) (p : prod A B), p.fst
let snd = lambda (A B : Type) (p : prod A B), p.snd

let pair_fst_pr =
  ∀ (U V : Type) (u : U) (v : V),
    (fst V U (pair V U v u)) ≡ v

do (lambda U V u v, refl v) : pair_fst_pr

let pair_eta_pr =
  ∀ (U V : Type) (x y : prod U V),
    fst U V x ≡ fst U V y ->
    snd U V x ≡ snd U V y ->
    x ≡ y

do (lambda U V x y (eq1 : x.fst == y.fst) (eq2 : x.snd == y.snd),
  now hints = add_hints [eq1,eq2] hints in
  refl x : x == y) : pair_eta_pr

constant C D : Type
constant p q : prod C D

dont refl p : p == q

do refl p : p == pair C D (fst C D p) (snd C D p)

