
let congr = (λ A f g u v eqf equ, handle
  match congruence (f u) (g v) with
    | Some ?eq => eq
  end with
    | equal f g => yield (Some eqf)
    | equal u v => yield (Some equ)
  end) : forall (A : Type) (f g : A -> A) (u v : A), f == g -> u == v -> f u == g v

do congr

let congr' = (λ A f g u v eqf equ, congr_apply (assume x : A in x) eqf equ (refl A) (refl A))
 : forall (A : Type) (f g : A -> A) (u v : A), f == g -> u == v -> f u == g v

do congr'
