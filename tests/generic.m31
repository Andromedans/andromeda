
signature cat = { person : Type, pet : person }

let person_id = match cat with |- _sig ?l => match l with [(?x,_,_),_] => x end end
let pet_id = match cat with |- _sig ?l => match l with [_,(?x,_,_)] => x end end

constant dwarf : Type

constant urist : dwarf

let ankle = { person = dwarf, pet = urist }

do ankle

do match ankle with
  | |- _struct ?x => x
  end

do match ankle with
  | |- _ : _sig ?x => x
  end

do match ankle.pet with
  | |- _proj ?x ?l => (x,l)
  end

do match cat with
  | |- _sig _ => tt
  end

do _struct cat [dwarf,urist]

fail _struct cat [dwarf,dwarf]

constant A : Type

do
  assume eq : A == cat in
  add_beta eq;
  _struct A [dwarf,urist]

do _proj ankle pet_id

let first_proj = fun v => match v with
  |- _ : _sig ?s => match s with
    | (?l,_,_)::_ =>
      _proj v l
    end
  end

do first_proj ankle

let last_proj = fun v => match v with
  |- _ : _sig ?s => match rev s with
    | (?l,_,_)::_ =>
      _proj v l
    end
  end

do last_proj ankle

signature treasure = { gold : A }

let gold_id = match treasure with |- _sig ?l => match l with [(?x,_,_)] => x end end

fail _proj urist gold_id

fail _proj ankle gold_id

do match assume x : A in x with
  |- _atom => tt
  end

fail match ankle with
  |- _atom => tt
  end

