
signature cat = { person : Type, pet : person }

let person_id = match cat with |- _sig ((_, [(?l,_),_]),_) => l end
let pet_id = match cat with |- _sig ((_, [_,(?l,_)]),_) => l end

constant dwarf : Type

constant urist : dwarf

let ankle = { person = dwarf, pet = urist }

do ankle

do match ankle with
  | |- _struct ?t ?x => (t,x)
  end

do match ankle with
  | |- _ : _sig ?x => x
  end

do match ankle.pet with
  | |- _proj ?x ?l => (x,l)
  end

do match cat with
  | |- _sig _ => ()
  end

do _struct cat [dwarf,urist]

fail _struct cat [dwarf,dwarf]

constant A : Type

do
  assume eq : A == cat in
  add_beta eq;
  _struct A [dwarf,urist]

do _proj ankle pet_id

let first_proj = fun v => match v with
  |- _ : _sig ((_,?s),_) => match s with
    | (?l,_)::_ =>
      _proj v l
    end
  end

do first_proj ankle

let last_proj = fun v => match v with
  |- _ : _sig ((_,?s),_) => match rev s with
    | (?l,_)::_ =>
      _proj v l
    end
  end

do last_proj ankle

signature treasure = { gold : A }

let gold_id = match treasure with |- _sig ((_,[(?l,_)]),_) => l end

fail _proj urist gold_id

fail _proj ankle gold_id

constant B : Type
constant eq : A == B
let _ = add_beta eq

do match assume x : A in x : B with
  |- _atom ?y => y
  end

fail match ankle with
  |- _atom _ => ()
  end

constant a : A
do match a : B with
  |- _constant ?y => y
end

