
signature cat = { person : Type, pet : person }

let person_id = ident person
let pet_id = ident pet

constant dwarf : Type

constant urist : dwarf

let ankle = { person = dwarf, pet = urist }

do ankle

do match ankle with
  | |- _struct ?t ?x => (t,x)
  end

do match ankle with
  | |- _ : _sig ?x => x
  end

do match ankle.pet with
  | |- _proj ?x ?l => (x,l)
  end

do match cat with
  | |- _sig _ => ()
  end

do _struct cat [dwarf,urist]

fail _struct cat [dwarf,dwarf]

constant A : Type

do
  assume eq : A == cat in
  now betas = add_beta eq betas in
  _struct A [dwarf,urist]

do _proj ankle pet_id

(* TODO 
let first_proj v = match v with
  |- _ : _sig ((_,?s),_) => match s with
    | (?l,_)::_ =>
      _proj v l
    end
  end

do first_proj ankle

let last_proj v = match v with
  |- _ : _sig ((_,?s),_) => match rev s with
    | (?l,_)::_ =>
      _proj v l
    end
  end

do last_proj ankle
*)

signature treasure = { gold : A }

let gold_id = ident gold

fail _proj urist gold_id

fail _proj ankle gold_id

constant B : Type
constant eq : A == B
now betas = add_beta eq betas

do match assume x : A in x : B with
  |- _atom ?y => y
  end

fail match ankle with
  |- _atom _ => ()
  end

constant a : A
do match a : B with
  |- _constant ?y => y
end

