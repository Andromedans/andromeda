match "foo" with _ => "bar" end ;;

match "foo" with x => x end ;;

match ("foo", "bar", "baz") with (x, y, z) => (z, x, y) end ;;

let (x, y, z) = ("foo", "bar", "baz") in (z, x, y) ;;

match ML.Some "foo" with
  | ML.Some s => s
  | ML.None => "WRONG ANSWER"
end ;;

rule A type ;;
rule a : A ;;
rule P (⊢ _ : A) type ;;

match a with
  | x : X => ([x; X], "isterm")
  | X ≡ Y => ([X; Y], "eqtype")
  | X type => ([X], "istype")
  | x ≡ y : X => ([x; y; X], "eqterm")
  | {x : X} jdg => ([x; X; jdg], "abstraction")
end ;;

match A with
  | x : X => ([x; X], "isterm")
  | X ≡ Y => ([X; Y], "eqtype")
  | X type => ([X], "istype")
  | x ≡ y : X => ([x; y; X], "eqterm")
  | {x : X} jdg => ([x; X; jdg], "abstraction")
end ;;

match P a with
  | x : X => ([x; X], "isterm")
  | X ≡ Y => ([X; Y], "eqtype")
  | X type => ([X], "istype")
  | x ≡ y : X => ([x; y; X], "eqterm")
  | {x : X} jdg => ([x; X; jdg], "abstraction")
end ;;

rule B type ;;
rule ξ : A ≡ B ;;

match ξ with
  | x : X => ([x; X], "isterm")
  | X ≡ Y => ([X; Y], "eqtype")
  | X type => ([X], "istype")
  | x ≡ y : X => ([x; y; X], "eqterm")
  | {x : X} jdg => ([x; X; jdg], "abstraction")
end ;;

rule b : A ;;
rule ζ : a ≡ b : A ;;

match ζ with
  | x : X => ([x; X], "isterm")
  | X ≡ Y => ([X; Y], "eqtype")
  | X type => ([X], "istype")
  | x ≡ y : X => ([x; y; X], "eqterm")
  | {x : X} jdg => ([x; X; jdg], "abstraction")
end ;;

match (convert a ξ) with
  | x : X => ([x; X], "isterm")
  | X ≡ Y => ([X; Y], "eqtype")
  | X type => ([X], "istype")
  | x ≡ y : X => ([x; y; X], "eqterm")
  | {x : X} jdg => ([x; X; jdg], "abstraction")
end ;;

match {z : A} P z with
  | x : X => ([x; X], "isterm")
  | X ≡ Y => ([X; Y], "eqtype")
  | X type => ([X], "istype")
  | x ≡ y : X => ([x; y; X], "eqterm")
  | {x : X} jdg => ([x; X; jdg], "abstraction")
end ;;
