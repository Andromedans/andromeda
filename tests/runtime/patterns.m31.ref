- : mlstring = "bar"
- : mlstring = "foo"
- : mlstring * mlstring * mlstring = ("baz", "foo", "bar")
- : mlstring * mlstring * mlstring = ("baz", "foo", "bar")
- : list mlstring * mlstring * mlstring * list mlstring * mlstring =
  ("foo" :: "bar" :: [], "baz", "foo", "bar" :: [], "baz")
- : mlstring = "foo"
Rule A is postulated.
Rule a is postulated.
Rule P is postulated.
val test_judgement :> judgement → list judgement * mlstring = <function>
- : list judgement * mlstring = (a :: A :: [], "isterm")
- : list judgement * mlstring = (A :: [], "istype")
- : list judgement * mlstring = (P a :: [], "istype")
Rule B is postulated.
Rule ξ is postulated.
- : list judgement * mlstring = (A :: B :: [], "eqtype")
Rule b is postulated.
Rule ζ is postulated.
- : list judgement * mlstring = (a :: b :: A :: [], "eqterm")
- : list judgement * mlstring = (a :: B :: [], "isterm")
- : list judgement * mlstring = (?z₀ :: A :: P ?z₀ :: [], "abstraction")
val test_boundary :> boundary → list judgement * list boundary * mlstring =
  <function>
- : list judgement * list boundary * mlstring = ([], [], "istype boundary")
- : list judgement * list boundary * mlstring =
  (A :: [], [], "isterm boundary")
- : list judgement * list boundary * mlstring =
  (P a :: [], [], "isterm boundary")
- : list judgement * list boundary * mlstring =
  (A :: P a :: [], (A ≡ P a as ?) :: [], "eqtype boundary")
- : list judgement * list boundary * mlstring =
  (a :: b :: A :: [], [], "eqterm boundary")
- : list judgement * list boundary * mlstring =
  (a :: b :: B :: [], [], "eqterm boundary")
- : list judgement * list boundary * mlstring =
  (?z₁ :: A :: [], (? : P ?z₁) :: [], "abstraction boundary")
Rule θ is postulated.
- : list judgement * list boundary * mlstring =
  (?z₂ :: B :: [], (? : P ?z₂) :: [], "abstraction boundary")
