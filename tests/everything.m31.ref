Operation unary_op is declared.
Operation nonary_op is declared.
Types dummy declared.
Types color declared.
Constant A is declared.
Constant a is declared.
Constant b is declared.
Constant ( + ) is declared.
Constant ( * ) is declared.
Constant ( ^ ) is declared.
Constant ( - ) is declared.
Constant ( <= ) is declared.
⊢ λ (x : A) (y : A) (z : A) (w : A), x + y * z ^ x ^ y - (z ^ x) ^ y <= w
  : A → A → A → A → A
Signature isContr is declared.
x0 is defined.
x : {isContr with T = Type ≡ Type} 
⊢ x : {isContr with T = Type ≡ Type}
The command failed with error:
File "./everything.m31", line 82, characters 6-9: Typing error
  this expression should be a product, found Type
⊢ refl Type : Type ≡ Type
The command failed with error:
File "./everything.m31", line 96, characters 6-18: Runtime error
  cannot infer the type of T
⊢ λ (T : Type) (x : T), x : Π (A0 : Type), A0 → A0
⊢ refl {} : {} ≡ {}
Signature wrapped is declared.
wrapped_a is defined.
⊢ refl {} : {} ≡ {}
⊢ λ (x : A), x : A → A
The command failed with error:
File "./everything.m31", line 114, characters 13-25: Runtime error
  cannot infer the type of x
The command failed with error:
File "./everything.m31", line 118, characters 21-22: Typing error
  the expression {} should have type {wrapped with unwrap = a} but has type
  unit
y_combinator is defined.
f is defined.
g is defined.
("f", ("g", "foo"))
wrapped = {unwrap : A}
()
Operation get is declared.
Operation set is declared.
state_h is defined.
⊢ b : A
⊢ Type : Type
(⊢ a : A) :: (⊢ b : A) :: (⊢ A : Type) :: <function> :: []
[]
(⊢ a : A, ⊢ b : A, ⊢ A : Type)
"a string\\nspecial characters aren't"
register is defined.
()
⊢ b : A
⊢ A : Type
x : A 
⊢ x : A
"this will happen"
()
alpha_equal is defined.
Constant exfalso is declared.
Signature container is declared.
⊢ {T = A} : {container with T, cont = exfalso T}
⊢ {T = A} : {container with T, cont = exfalso T}
⊢ {cont = exfalso A} : {container with T = A}
⊢ {cont = exfalso A} : {container with T = A}
⊢ {cont = a} : {container with T = A}
⊢ {unwrap = a}.unwrap : A
x : wrapped 
⊢ x.unwrap : A
⊢ a : A
⊢ a : A
((⊢ wrapped : Type, (unwrap, unwrap : A 
                               ⊢ unwrap : A) :: []), Constrained
(⊢ a : A) :: [])
(⊢ {container with T = A} : Type, (⊢ a : A) :: [])
(x : wrapped 
 ⊢ x : wrapped, unwrap)
Tvar is defined.
yvar is defined.
dependent is defined.
Some (⊢ Type : Type)
None
(T : Type 
 ⊢ T : Type) :: (T : Type 
                   x : T 
                   ⊢ x : T) :: []
Operation emit is declared.
(x : A 
 ⊢ x : A) :: []
Constant eq is declared.
⊢ refl a : a ≡ a
⊢ refl a : a ≡ b
Some (⊢ refl ((λ (x : A), x) a) : (λ (x : A), x) a ≡ a)
Some (⊢ refl {unwrap = a}.unwrap : {unwrap = a}.unwrap ≡ a)
Some
(⊢ refl {wrapped with unwrap = a}
   : {wrapped with unwrap = a} ≡ {wrapped with unwrap = b})
⊢ λ (x : unit), refl x : Π (x : unit), x ≡ {}
⊢ λ (A0 : Type) (x : A0) (y : A0) (p : x ≡ y) (_ : x ≡ y), refl p
  : Π (A0 : Type) (x : A0) (y : A0) (p : x ≡ y) (q : x ≡ y), p ≡ q
#including ./../std/hippy.m31
#processed ./../std/hippy.m31
