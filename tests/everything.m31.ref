Operation unary_op is declared.
Operation nonary_op is declared.
Data constructor dummy is declared.
Data constructor black is declared.
Data constructor rgb_color is declared.
Constant A is declared.
Constant a is declared.
Constant b is declared.
Constant ( + ) is declared.
Constant ( * ) is declared.
Constant ( ^ ) is declared.
Constant ( - ) is declared.
Constant ( <= ) is declared.
⊢ λ (x : A) (y : A) (z : A) (w : A), x + y * z ^ x ^ y - (z ^ x) ^ y <= w
  : A → A → A → A → A
Signature isContr is declared.
x0 is defined.
x₂₂ : {isContr with T = Type ≡ Type} 
⊢ x₂₂ : {isContr with T = Type ≡ Type}
The command failed with error:
File "./everything.m31", line 81, characters 6-9: Typing error
  this expression should be a product, found Type
⊢ refl Type : Type ≡ Type
⊢ λ (T : Type) (x : T), x : Π (A0 : Type), A0 → A0
⊢ refl {} : {} ≡ {}
Signature wrapped is declared.
wrapped_a is defined.
⊢ refl {} : {} ≡ {}
⊢ λ (x : A), x : A → A
The command failed with error:
File "./everything.m31", line 112, characters 13-25: Runtime error
  cannot infer the type of x
The command failed with error:
File "./everything.m31", line 116, characters 21-22: Typing error
  the expression {} should have type {wrapped with unwrap = a} but has type
  unit
y_combinator is defined.
f is defined.
g is defined.
("f", ("g", "foo"))
wrapped = {unwrap : A}
()
Operation get is declared.
Operation set is declared.
state_h is defined.
⊢ b : A
⊢ Type : Type
[⊢ a : A, ⊢ b : A, ⊢ A : Type, <function>]
[]
(⊢ a : A, ⊢ b : A, ⊢ A : Type)
"a string\\nspecial characters aren't"
register is defined.
()
⊢ b : A
⊢ A : Type
x₃₂ : A 
⊢ x₃₂ : A
"this will happen"
()
alpha_equal is defined.
Constant exfalso is declared.
Signature container is declared.
⊢ {T = A} : {container with T, cont = exfalso T}
⊢ {T = A} : {container with T, cont = exfalso T}
⊢ {cont = exfalso A} : {container with T = A}
⊢ {cont = exfalso A} : {container with T = A}
⊢ {cont = a} : {container with T = A}
⊢ {unwrap = a}.unwrap : A
x₄₄ : wrapped 
⊢ x₄₄.unwrap : A
⊢ a : A
⊢ a : A
((⊢ wrapped : Type, [(unwrap, unwrap₄₆ : A 
                                ⊢ unwrap₄₆ : A)]), [Constrained
(⊢ a : A)])
(⊢ {container with T = A} : Type, [⊢ a : A])
(x₄₉ : wrapped 
 ⊢ x₄₉ : wrapped, unwrap)
Tvar is defined.
yvar is defined.
dependent is defined.
Some (⊢ Type : Type)
None
[T₅₀ : Type 
 ⊢ T₅₀ : Type,
T₅₀ : Type 
x₅₂ : T₅₀ 
⊢ x₅₂ : T₅₀]
Operation emit is declared.
[x₅₃ : A 
 ⊢ x₅₃ : A]
Constant eq is declared.
⊢ refl a : a ≡ a
⊢ refl a : a ≡ b
Some (⊢ refl ((λ (x : A), x) a) : (λ (x : A), x) a ≡ a)
Some (⊢ refl {unwrap = a}.unwrap : {unwrap = a}.unwrap ≡ a)
Some
(⊢ refl {wrapped with unwrap = a}
   : {wrapped with unwrap = a} ≡ {wrapped with unwrap = b})
⊢ λ (x : unit), refl x : Π (x : unit), x ≡ {}
⊢ λ (A0 : Type) (x : A0) (y : A0) (p : x ≡ y) (_ : x ≡ y), refl p
  : Π (A0 : Type) (x : A0) (y : A0) (p : x ≡ y) (q : x ≡ y), p ≡ q
#including ../std/hippy.m31
#processed ./../std/hippy.m31
#including everything.m31
#processed ./everything.m31
#including ../std/base.m31
#processed ./../std/base.m31
#including ../std/equal.m31
#processed ./../std/equal.m31
#including ../std/base.m31
#processed ./../std/base.m31
Toplevel directives:
#environment. .... print current environment
#help. ........... print this help
#quit. ........... exit

Parameter <ident> ... <ident> : <type> .     assume variable <ident> has type <type>
Let <ident> := <expr> .                      define <ident> to be <expr>
Check <expr> .                               check the type of <expr>

The syntax is vaguely Coq-like. The strict equality is written with a double ==.

constant eq a ≡ b
constant exfalso Π (T : Type), T
constant ( <= ) A → A → A
constant ( - ) A → A → A
constant ( ^ ) A → A → A
constant ( * ) A → A → A
constant ( + ) A → A → A
constant b A
constant a A
constant A Type
data rgb_color 3
data black 0
data dummy 0
data lazy 0
data eager 0
data ( !! ) 1
data Constrained 1
data Unconstrained 1
data None 0
data Some 1
operation hippy 0
operation emit 1
operation set 1
operation get 0
operation nonary_op 0
operation unary_op 1
operation whnf 1
operation failure 1
operation as_signature 1
operation as_eq 1
operation as_prod 1
operation equal 2
signature container T : Type, cont : T
signature wrapped unwrap : A
signature isContr T : Type, center as a0 : T,
    contr_path as _ : Π (x : T), a0 ≡ x
signature unit 

