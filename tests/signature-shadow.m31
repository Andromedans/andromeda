
constant A : Type
constant a : A

let proj_x v = v.x

signature orig = { x : A }

do { x = a }

do { } : {orig with x = a}

do { x as y } : {orig with x as z = a}

do proj_x {x = a}

signature copy = { x : A }

do { x = a }

do { x = a } : orig

let s_orig = { } : {orig with x = a}
let s_copy = { } : {copy with x = a}

fail refl { } : s_orig == s_copy


constant B : Type
constant b : B

signature prod = { x : A, y : B }

do { x = a } : {prod with y = b}

signature wrap = { T : Type, T' : Type, v : T }

constant exfalso : forall (T : Type), T
operation inhab 0

(* Not mentioning a field is no guarantee against it being used. We could also grab it from hypotheses. *)
do { T = A, T' = B } : (handle {wrap with v = inhab} with
  | inhab : Some ?T => yield (exfalso T)
  end)

