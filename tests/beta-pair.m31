constant Product : Type -> Type -> Type

constant Pair :
  Π (A B : Type),
    A -> (B -> (Product A B))

constant Fst :
  Π (X Y : Type), Product X Y -> X

constant beta_Fst :
  Π (U V : Type, u : U, v : V),
    (Fst V U (Pair V U v u)) == v

constant C : Type
constant D : Type
constant c : C
constant d : D

(* just a Pair *)
check with equality_in betas hints handle
  let _ = beta beta_Fst in
    (refl (Fst C D (Pair C D c d)))
         :
         c == (Fst C D (Pair C D c d))

(* change the order of the parameters *)
check with equality_in betas hints handle
  let _ = beta beta_Fst in
       (refl (Fst D C (Pair D C d c)))
         :
         d == (Fst D C (Pair D C d c))

(* add a lambda redex in the proof *)
check with equality_in betas hints handle
  let _ = beta beta_Fst in
    (refl (Fst C D (Pair C D ((λ (t : Type, x : t), x) C c) d)))
         :
         c == (Fst C D (Pair C D c d))

(* add a lambda redex in the type *)
check with equality_in betas hints handle
  let _ = beta beta_Fst in
    (refl (Fst C D (Pair C D c d)))
         :
         c == (Fst C D (Pair C D ((λ (t : Type, x : t), x) C c) d))

