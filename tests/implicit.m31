#include_once "../std/new_equal.m31"

constant A : Type
constant a : A
constant f g h : A -> A
constant g_def : g == (lambda x : A, f (f x))
constant h_def : h == g

let imps = [(g, ([], g, ref (Some g_def))), (h, ([], h, ref (Some h_def)))]

do whnf_term imps (h (g (h a)))

(* Trying to solve an equation *)
let id = lambda (A : Type) (x : A), x

do
  with implicits handle
   id ? a

do
  with implicits handle
    resolve (id ? a)

do
  with implicits handle
    (id (id ? ?) a)

(* Here we need to be careful about order of resolution,
   but it is taken care of by the handler. *)
do
  with implicits handle
    resolve (id (id ? ?) a)

do
  with implicits handle
  assume x : ? in x


do
  with implicits handle
    assume s : ? in
    assume t : ? in
    let _ = s == t in
    (s, resolve t)

do
  with implicits handle
    resolve (refl a : ?)

do
  with implicits handle
    resolve (λ (B : Type) (b : B), id ? b)

fail
  with implicits handle
  assume f : ∏ (x : A), (∏ (y : A), x ≡ y) → A in
    f ? (λ y, refl y)

do
  with implicits handle
    let f = id ? in
    resolve (lambda (x : A), f x)

fail
  with implicits handle
    let f = id ? in
    resolve (lambda (B : Type) (x : B), f x)

do
  with implicits handle
    let f = fun y => id ? y in
    resolve (lambda (B : Type) (x : f B), f (f x))

do
  with implicits handle
  resolve (lambda (x : A), (refl x : ?))

do
  with implicits handle
  resolve ((lambda (f : A -> A), f (f a)) : ?)
