#include_once "../std/new_equal.m31"

constant A : Type
constant a : A
constant f g h : A -> A
constant g_def : g == (lambda x : A, f (f x))
constant h_def : h == g

let imps = [(g, ref (Some g_def)), (h, ref (Some h_def))]

do whnf_term imps (h (g (h a)))

(* Trying to solve an equation *)
let id = lambda (A : Type) (x : A), x

do assume U : Type in
     let imps = (U, ref None) :: imps in
     handle
       whnf_term imps (id U (id U a))
     with
       coerce (|- _ : ?B) ?C =>
         match equal_ty imps B C with
         | Some ?xi => yield (Convertible xi)
         | None => yield NotCoercible
         end
     end

(* Does it work with several levels of definitions? *)

constant T : Type -> Type

constant cow : forall A B : Type, A -> B -> Type


fail
   assume X : Type in
   assume Y : Type in
   assume Z : Type in
   assume W : Type in
   let imps = [(X, ref None), (Y, ref None), (Z, ref None), (W, ref None)] in
   handle
     let a = lambda y : Y, (y : T X) in
     let b = lambda x : X, (x : T Y) in
     cow Z W a b
   with
     coerce (|- _ : ?B) ?C =>
       match equal_ty imps B C with
       | Some ?xi => yield (Convertible xi)
       | None => yield NotCoercible
       end
   end

do
  with implicits handle
    resolve (id ? a)

do
  with implicits handle
    (id (id ? ?) a)

(* Here we need to be careful about order of resolution,
   but it is taken care of by the handler. *)
do
  with implicits handle
    resolve (id (id ? ?) a)

do
  with implicits handle
  assume x : ? in x


(* XXX this looks like a bug, since it gives 

   imp₀ : Type
   s₁ : imp₀
   imp₂ : Type
   t₃ : imp₂
   eq₄ : imp₂ ≡ imp₀
   ⊢ s₁ ≡ t₃ : Type
*)
do
  with implicits handle
    assume s : ? in
    assume t : ? in
    s == t

(* repeat the bug without implicits handler *)
do
  assume X : Type in
  assume Y : Type in
  assume x : X in
  assume y : Y in
  let imps = [(X, ref None), (Y, ref None)] in
  handle
    x == y
   with
     coerce (|- _ : ?B) ?C =>
       match equal_ty imps B C with
       | Some ?xi => yield (Convertible xi)
       | None => yield NotCoercible
       end
   end
   

