Parameter empty : Type.
Parameter empty_rect : forall (P : empty -> Type) (x : empty), P x.

Let from_empty :=
 (fun X => empty_rect (fun x => X))
 : forall (X : Type), empty -> X.

Parameter unit : Type.
Parameter tt : unit.
Parameter unit_rect: forall (P : unit -> Type) (x : P tt) (u : unit), P u.

Parameter unit_iota: forall (P : unit -> Type) (x : P tt), unit_rect P x tt == x.

Parameter unit_eta : forall (t u : unit), t == u.

Let to_unit :=
  (fun X x => tt)
  : forall (X : Type), X -> unit.

Let termfun :=
  (fun X x _ => x)
  : forall (X : Type) (x : X), unit -> X.

Let idfun := fun (X : Type) (x : X) => x.

Let funcomp :=
  fun (X Y Z : Type) (f : X -> Y) (g : Y -> Z) (x : X) => g (f x).

(* Natural numbers. *)
Parameter nat : Type.

Parameter O : nat.

Parameter S : nat -> nat.

Parameter nat_rect : forall (P : nat -> Type) (s0 : P O) (s : forall n : nat, P n -> P (S n)) (m : nat), P m.

Parameter nat_iota_O :
  forall (P : nat -> Type) (s0 : P O) (s : forall n : nat, P n -> P (S n)),
  nat_rect P s0 s O == s0.

Parameter nat_iota_S :
  forall (P : nat -> Type) (s0 : P O) (s : forall n : nat, P n -> P (S n)) (m : nat),
  nat_rect P s0 s (S m) == s m (nat_rect P s0 s m).

Let iteration := 
  (fun T f n => nat_rect (fun _ => T -> T) (idfun T) (fun j IHn => funcomp T T T f IHn) n)
  : forall (T : Type), (T -> T) -> nat -> (T -> T).

Let iteration' := 
  (fun (T:Type) (f:T->T) (n:nat) (x:T) => nat_rect (fun i => T) x (fun j IHn => f IHn) n)
  : forall (T : Type), (T -> T) -> nat -> (T -> T).

Let iteration'' := 
  (fun T f n x => nat_rect (fun i => T) x (fun j IHn => f IHn) n)
  : forall (T : Type), (T -> T) -> nat -> (T -> T).

Let iteration''' := 
  (fun (T:Type) (f:T->T) (n:nat) (x:T) => nat_rect (fun i => T) x (fun j IHn => f IHn) n).

Check refl iteration' : iteration'' == iteration'.


(*
Check
  beta nat_iota_O in
  beta nat_iota_S in
    nat_rect (fun _ => nat) (S O) (fun _ => idfun nat) (S (S O)) == S O.
*)

Check
    refl (iteration' nat S O O) :
    iteration' nat S O O == (fun (T:Type) (f:T->T) (n:nat) (x:T) => nat_rect (fun i => T) x (fun j IHn => f IHn) n) nat S O O.
(*
    nat_rect
    (fun (_ : nat) => nat)
    O
    (fun (m : nat) (IHn : (fun (_ : nat) => nat) m) => S IHn)
    O.
*)
Let k := iteration' nat S (S (S O)) (S O).
Check k.

Check
  beta nat_iota_O in
   beta nat_iota_S in
      (refl k) : k == (S (S (S O))).
