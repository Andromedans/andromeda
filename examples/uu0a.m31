(* Transcription of the uu0a.coq file from UniMath *)

Parameter empty : Type.
Parameter empty_rect : forall (P : empty -> Type) (x : empty), P x.

Let from_empty :=
 (fun X => empty_rect (fun x => X))
 : forall (X : Type), empty -> X.

Parameter unit : Type.
Parameter tt : unit.
Parameter unit_rect: forall (P : unit -> Type) (x : P tt) (u : unit), P u.

Parameter unit_iota: forall (P : unit -> Type) (x : P tt), unit_rect P x tt == x.

Parameter unit_eta : forall (t u : unit), t == u.

Let to_unit :=
  (fun X x => tt)
  : forall (X : Type), X -> unit.

Let termfun :=
  (fun X x _ => x)
  : forall (X : Type) (x : X), unit -> X.

Let idfun := fun (X : Type) (x : X) => x.

Let funcomp :=
  fun (X Y Z : Type) (f : X -> Y) (g : Y -> Z) (x : X) => g (f x).

(* Natural numbers. *)
Parameter nat : Type.

Parameter O : nat.

Parameter S : nat -> nat.

Parameter nat_rect : forall (P : nat -> Type) (s0 : P O) (s : forall n : nat, P n -> P (S n)) (m : nat), P m.

Parameter nat_iota_O :
  forall (P : nat -> Type) (s0 : P O) (s : forall n : nat, P n -> P (S n)),
  nat_rect P s0 s O == s0.

Parameter nat_iota_S :
  forall (P : nat -> Type) (s0 : P O) (s : forall n : nat, P n -> P (S n)) (m : nat),
  nat_rect P s0 s (S m) == s m (nat_rect P s0 s m).

Let iteration :=
  (fun T f n => nat_rect (fun _ => T -> T) (idfun T) (fun _ IHn => funcomp T T T f IHn) n)
  : forall (T : Type), (T -> T) -> nat -> (T -> T).

Check
  beta nat_iota_S in
  beta nat_iota_O in
    refl (S (S O)) :
    iteration nat S O (S (S O)) == S (S O).

Let k := iteration nat S (S (S O)) (S O).
Check k.

Beta nat_iota_O.
Beta nat_iota_S.

Check (refl k) : k == (S (S (S O))).
