(** The definition of booleans. *)

Parameter bool : Type.
Parameter true false : bool.

Parameter ind_bool :
  forall (P : bool -> Type) (x : P true) (y : P false), forall b : bool, P b.

Parameter ind_bool_true :
  forall (P : bool -> Type) (x : P true) (y : P false), ind_bool P x y true == x.

Parameter ind_bool_false :
  forall (P : bool -> Type) (x : P true) (y : P false), ind_bool P x y false == y.

(* Parameter ind_bool_eta : *)
(*   forall (P : bool -> Type) *)

#include "empty.m31" "unit.m31"

(* Be very careful about when reductions may happen. *)
Let bool_disjoint :=
  (fun (p : true == false) =>
     let P :=
         fun (b : bool) => ind_bool (fun (_ : bool) => Type) unit empty b
     in
     let p :=
       beta p in
         (refl (P true) : P true == P false) in
     let p :=
       beta ind_bool_false in
         p : P true == empty in
     let p :=
       beta ind_bool_true in
         p : unit == empty in
     beta p in
       tt : empty)
    :
    true == false -> empty.

(* Let's be less careful. *)
Beta ind_bool_true.
Beta ind_bool_false.

Let bool_disjoint' :=
  (fun (p : true == false) =>
     let P := fun (b : bool) => ind_bool (fun (_ : bool) => Type) unit empty b in
     let p :=
       beta p in
         (refl (P true) : P true == P false) in
     let p := p : unit == empty in
     beta p in
       tt : empty)
    :
    true == false -> empty.

(* The information propagates inwards. *)
Let bool_disjoint'' :=
  (fun (p : true == false) =>
     let P := fun (b : bool) => ind_bool (fun (_ : bool) => Type) unit empty b in
     let p := beta p in (refl empty : P true == empty) in
     let p := p : unit == empty in
     beta p in tt)
    :
    true == false -> empty.

Check bool_disjoint''.
