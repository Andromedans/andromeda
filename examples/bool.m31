(** The definition of booleans. *)

constant bool : Type
constant true : bool
constant false : bool
constant ind_bool :
  Π (P : bool -> Type) (x : P true) (y : P false), Π (b : bool), P b

constant ind_bool_true :
  Π (P : bool -> Type) (x : P true) (y : P false), ind_bool P x y true == x

constant ind_bool_false :
  Π (P : bool -> Type) (x : P true) (y : P false), ind_bool P x y false == y

(* We prove that "if b then true else false" equals "b". *)
do
 with local (lbeta ind_bool_true) handle
 with local (lbeta ind_bool_false) handle
 ((ind_bool
       (λ b, ind_bool (λ _, bool) true false b == b)
       (refl true)
       (refl false))
  : Π (b : bool), ind_bool (λ _, bool) true false b == b)

do Type

(* Next we show that true and false are not equal. *)

 #include "empty.m31" "unit.m31"

(* Be very careful about when reductions may happen
   Better hint management would help here. *)

(* Be very careful about when reductions may happen. *)
let bool_disjoint : true ≡ false → empty =
    λ (p : true == false),
     let P =
         λ (b : bool), ind_bool (λ (_), Type) unit empty b
     in
     let p =
       with local (lbeta p) handle
         (refl (P true) : P true == P false) in
     let p =
       with local (lbeta ind_bool_false) handle
         p : P true == empty in
     let p =
       with local (lbeta ind_bool_true) handle
         p : unit == empty in
     with local (lbeta p) handle
       let u = {} in u : empty

(* let's be less careful. *)
do add_beta ind_bool_true
do add_beta ind_bool_false

let bool_disjoint' (p : true == false) : empty =
     let P = λ (b : bool), ind_bool (λ (_ : bool), Type) unit empty b in
     let p =
       with equality empty_state handle (* need to remove global hints else P true --> unit and P false --> empty *)
         let _ = beta p in
         (refl (P true) : P true == P false) in
     let p = p : unit == empty in
     with local (lbeta p) handle
       let u = {} in u : empty

do bool_disjoint'

