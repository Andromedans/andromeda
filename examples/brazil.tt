assume nat : type 
assume O : nat
assume S : nat -> nat

assume List : nat -> type

/////////////////////////
// Pairing and Projection
/////////////////////////

define p1 := (O, S(O))
define n2 := p1.fst


assume l3 : List (S(S(S(O))))
assume length : (n : nat) -> List n -> nat

assume p2 : (n : nat) * (List n)
define ln := p2.snd
define p3 := (S(S(S(O))), l3)
define p4 := ( (S(S(S(O))), l3) :> (n:nat) * List(n) )


////////////////////
// Equivalence Types
////////////////////

assume plus : nat -> nat -> nat
assume oneonetwo : plus (S O) (S O) == S(S(O)) @ nat
assume sym : (x:nat) -> (y:nat) -> (x == y @ nat) -> (y == x @ nat)

define twooneone := sym (plus (S O) (S O)) (S(S(O))) oneonetwo


define zero_equal_zero := refl O
define zero_equiv_zero := Refl O

////////////////////////
// Brazil-Style Handlers
////////////////////////

assume one : nat
assume won : nat
assume homonym : (one == won @ nat)

assume singleton_extract : List one -> nat
assume mylist : List won

define answer := handle singleton_extract mylist
                 with   homonym
                 end

//////////////////////////////
// Deeper equivalence checking
//////////////////////////////


// One handler
//
assume pair1 : List won * (List won -> List one)

with homonym          // The downside of this syntax is
                      // That there's no way to end the scope of this
                      // handler...
define pair2 := (pair1 :> List one * (List one -> List won))

// Multiple handlers, alternate == @ syntax

assume red : nat
assume crimson : nat
assume synonym : Eq nat red crimson 

assume pair3 : List red * List won

define pair4 := handle
                  (pair3 :> List crimson * List one)
                with
                  // homonym |              // Already installed above
                  synonym
                  | oneonetwo | zero_equiv_zero // Yes, these are unnecessary
                end

//////////////////////////
// Another example
//////////////////////////
assume a b c d : nat
assume Eab : a == b @ nat
assume Ecd : c == d @ nat
define u := (a, c)
define v := (b, d)

define make_pair_equality :=
  fun (x y z w : nat) (p : x == y @ nat) (q : z == w @ nat) =>
  (handle (Refl (x,z) :> (x,z) == (y,w) @ nat * nat) with p | q end)

define Euv := make_pair_equality a b c d Eab Ecd


//////////////////////////
// Type-Conversion testing
//////////////////////////

assume T : Type
assume T_eq : (nat -> nat == T @ Type)
assume f : T

with T_eq
define app := f O

define eta_test := (Refl f :>  (f == (fun x : nat => f x) @ T))

#context

