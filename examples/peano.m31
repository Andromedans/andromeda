(* The definition of unary natural numbers. *)

constant N : Type
constant Z : N
constant S : N → N

constant ind_N :
  ∀ (P : N → Type), P Z → (∀ (n : N), P n → P (S n)) → ∀ (m : N), P m

constant ind_N_Z :
  ∀ (P : N → Type) (x : P Z) (f : ∏ (n : N), P n → P (S n)),
    ind_N P x f Z ≡ x

constant ind_N_S :
  ∀ (P : N → Type) (x : P Z) (f : ∏ (n : N), P n → P (S n)) (m : N),
    ind_N P x f (S m) ≡ f m (ind_N P x f m)

(* It looks like the best way to define new things is not with a let-binding,
   which always automatically unfolds the definition, but rather by introducing
   a new constant and a new equation. *)

constant pred : N → N
constant pred_Z : pred Z ≡ Z
constant pred_S : ∏ (x : N), pred (S x) ≡ x

constant pred' : N → N
constant pred'_def :
  ∀ (x : N), pred' x ≡ ind_N (λ (_ : N), N) Z (λ (x' _ : N), x') x

do with fasteq tt handle
  beta ind_N_Z; beta ind_N_S; beta pred'_def;
  refl (S Z) : pred' (S (S Z)) ≡ (S Z)

(* We define plus in such a way that it will unfold only when it is applied
   to two arguments. This seems to be an advantage. *)
constant plus : N → N → N
constant plus_def :
  ∀ (x y : N), plus x y ≡ ind_N (λ (_ : N), N) x (λ (_ : N), S) y

(* We now use the ind_N computation rules to establish properties of plus
   Later we use these properties to compute with plus -- we do not have to
   always go back to ind_N. *)
let plus_Z = with fasteq tt handle
  (λ (x : N),
    beta plus_def;
    beta ind_N_Z;
      refl (plus x Z) :
        plus x Z ≡ x)
 :
 ∀ (x : N), plus x Z ≡ x

let plus_S = with fasteq tt handle
  (λ (x y : N),
     beta plus_def;
     beta ind_N_S;
     refl (plus x (S y)) :
       plus x (S y) ≡ S (plus x y))
  :
  ∀ (x y : N), plus x (S y) ≡ S (plus x y)

(* We can compute with these rules. *)

let one   = S Z
let two   = S (S Z)
let three = S (S (S Z))
let four  = S (S (S (S Z)))
let five  = S (S (S (S (S Z))))
let six   = S (S (S (S (S (S Z)))))
let seven = S (S (S (S (S (S (S Z))))))
let eight = S (S (S (S (S (S (S (S Z)))))))
let nine  = S (S (S (S (S (S (S (S (S Z))))))))

do with fasteq tt handle
  beta pred_Z; beta pred_S;
    refl four : pred five ≡ four

do with fasteq tt handle
  beta pred_Z; beta pred_S;
    refl Z : pred Z ≡ Z

do with fasteq tt handle
  beta plus_Z;
  beta plus_S;
    refl five : plus two three ≡ plus one four

(* let us establish commutativity of addition. *)

let plus_Z' = with fasteq tt handle
  ind_N
    (λ (x : N), plus Z x ≡ x)
    (plus_Z Z)
    (λ (x : N) (IH : plus Z x ≡ x),
       beta IH;
       beta plus_S;
         refl (S (plus Z x)) : plus Z (S x) ≡ S x)
  : ∀ (x : N), plus Z x ≡ x

let plus_S' = with fasteq tt handle
  (λ (x y : N),
    beta plus_Z;
    beta plus_S;
    ind_N
      (λ (z : N), plus (S x) z ≡ S (plus x z))
      (refl (S x))
      (λ (z : N) (IH : plus (S x) z ≡ S (plus x z)),
       beta IH;
       beta plus_S;
         refl (plus (S x) (S z)) : plus (S x) (S z) ≡ S (plus x (S z)))
      y)
  : ∀ (x y : N), plus (S x) y ≡ S (plus x y)

let plus_commute = with fasteq tt handle
  (λ (x y : N),
    beta plus_Z;
    beta plus_S;
    beta plus_Z';
    beta plus_S';
    ind_N
      (λ (z : N), plus z y ≡ plus y z)
      (refl y)
      (λ (z : N) (IH : plus z y ≡ plus y z),
          beta IH;
           refl (S (plus z y)) : plus (S z) y ≡ plus y (S z) )
      x)
  : ∀ (x y : N), plus x y ≡ plus y x

do plus_commute

(* Using commutativity we can now verify that if a : P (x + y) then a : P (y + x). *)
do with fasteq tt handle
  hint plus_commute;
   (λ (P : N → Type) (x y : N) (a : P (plus x y)), a : P (plus y x))

(** (times n m) computes m*n as n-fold sum of m. *)
constant times : N → N → N
constant times_def : ∀ (n m : N), times n m ≡ ind_N (λ (_ : N), N) Z (λ (_ : N), plus m) n

do with fasteq tt handle
  beta times_def;
    beta ind_N_Z;
    refl Z : times Z two ≡ Z

(* TODO *)
fail with fasteq tt handle
  beta times_def;
    beta plus_def;
    beta ind_N_Z;
    beta ind_N_S;
    refl Z : times two Z ≡ Z

(* TODO *)
fail with fasteq tt handle
  beta times_def;
    beta plus_def;
    beta ind_N_Z;
    beta ind_N_S;
    refl (plus two four) : times three two ≡ (plus two four)


(** (exp b p) is the naive definition b^e as p-fold product of b. *)
constant exp : N → N → N
constant exp_def :
  ∀ (base power : N), exp base power ≡ ind_N (λ (_ : N), N) one (λ (_ : N), times base) power

(* TODO *)
fail with fasteq tt handle
  beta exp_def;
  beta times_def;
  beta plus_def;
  beta ind_N_Z;
  beta ind_N_S;
    refl four : exp two two ≡ four

let nine' = times three three
let ten' = plus five five

(* TODO *)
fail with fasteq tt handle
  beta exp_def;
  beta times_def;
  beta plus_def;
  beta ind_N_Z;
  beta ind_N_S;
    refl nine' : exp three two ≡ nine'

(* 2^7 is okay, 2^10 takes some time and memory *)
(* TODO *)
fail with fasteq tt handle
  beta exp_def;
  beta times_def;
  beta plus_def;
  beta ind_N_Z;
  beta ind_N_S;
    refl (exp two (plus three four)) : exp two (plus three four) ≡ times two (exp two (plus four two))

