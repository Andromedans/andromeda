(* Definition of propositional truncation. *)

Definition Type := Universe f0.

(* The type former *)
Parameter Trunc : Type -> Type.

(* Definition of something being a (-1)-type *)

Definition is_prop := fun (A : Type) => forall (x y : A), x = y.

(* The type constructors for propositional truncation *)

Parameter trunc : forall (A : Type), A -> Trunc A.

Parameter Trunc_is_prop : forall (A : Type), is_prop (Trunc A).

(* The non-dependent eliminator *)

Parameter rec_trunc :
  forall (A B : Type), is_prop B -> (A -> B) -> (Trunc A -> B).

(* The computation rule for trunc_elim *)

Parameter trunc_comp :
  forall (A B : Type)
         (p : is_prop B)
         (f : A -> B)
         (x : A),
    rec_trunc A B p f (trunc A x) == f x.

Rewrite trunc_comp.

(* Contractible types *)

Definition is_contr :=
   fun (A : Type) =>
   { center: A ;
     center_to: (forall y : A, center = y)
    }.

Definition sanity :=
  fun (A : Type) (c : is_contr A) (a : A) => c.center_to.

#context

(* If A is an inhabited proposition then it is contractible. *)

Definition inhab_prop_is_contr :
  forall (A : Type) (p : is_prop A), A -> is_contr A 
  :=
  fun (A : Type) (p : is_prop A) (a : A) =>
  { center = a ;
    center_to = (fun b : A => p center b) }.

#context

(* Concatentaion and opposite paths *)
Definition opp :=
  fun (A : Type) (a b : A) (q : a = b) =>
    J ([x y p . y = x], [z . idpath z], q).

Definition concat :=
  fun (A : Type) (a b c : A) (r : a = b) (s : b = c) =>
    J ([x y p . forall (d : A)  (q : y = d), x = d],
       [z . fun (d : A) (q : z = d) => q],
       r)
    c s.        

#context
        
(*

(* If A is contractible then it is a proposition *)
Definition contr_is_inhab_prop :
  forall (A : Type), is_contr A -> { 1 : A ; 2 : is_prop A }
  :=
  fun (A : Type) (c : is_contr A) =>
    { 1 = c.center ;
      2 = (fun (x y : A) => concat A x c.center y (opp A c.center x (c.center_to x)) (c.center_to y))
    }.

// Now we show that the truncation of booleans is the interval

// First we need the booleans

assume bool : Type
assume true false : bool
assume cond : (A : QuasiType 1) -> bool -> A -> A -> A

assume cond_true  : (A : QuasiType 1) -> (a : A) -> (b : A) -> cond A true a b == a @ A
assume cond_false : (A : QuasiType 1) -> (a : A) -> (b : A) -> cond A false a b == b @ A

assume ind_bool : (P : bool -> QuasiType 1) -> P false -> P true -> (b : bool) -> P b

// We need transport

define tr :=
  (fun (A : Type) (P : A -> Type) (a b : A) (s : a = b @ A) (u : P a) =>
    Ind (s, 
         x . y . p . (P x -> P y), 
         z . (fun v : P z => v)) u)
  :>
  forall (A : Type) (P : A -> Type) (a b : A) (s : a = b @ A), P a -> P b

// How to prove that two elements of a sigma type are equal

define total_path :
  forall (A : Type) (P : A -> Type) (a : A) (u : P a) (b : A) (v : P b) (p : a = b @ A),
    (tr A P a b p u = v @ P b) -> (a, u) = (b, v) @ ((x : A) * P x)
  :=
  fun A P a u b v p q =>
    Ind (p,
         x . y . s .
           (forall (u : P x) (v : P y) (q : tr A P x y s u = v @ P y),
             (x, u) = (y, v) @ ((x : A) * P x)),
         z . (fun (u v : P z) (q : u = v @ P z) =>
              Ind (q,
                   u . v . q . (z, u) = (z, v) @ ((x : A) * P x),
                   w . idpath ((z, w) :> ((x : A) * P x))
                  ))
        ) u v q

// We need singletons

define singleton := 
  fun (A : Type) (x : A) => exists (y : A), x = y @ A ;;

// TO DO
assume singleton_is_prop : forall (A : Type) (x : A), is_prop (singleton A x)
    
// Now we define the interval, but we only consider the non-dependent eliminator

define I := Trunc bool
define zero := trunc bool false
define one := trunc bool true
define seg := Trunc_is_prop bool zero one

// auxiliary definition
define rec_I_aux :
  forall (A : Type) (a b : A), (a = b @ A) -> I -> singleton A a
  :=
  fun A a b p =>
     rec_trunc bool (singleton A a) (singleton_is_prop A a)
                      (fun (c : bool) => cond (singleton A a) c (b, p) (a, idpath a))

define rec_I :=
   (fun A a b p x => (rec_I_aux A a b p x).1)
   :> 
   forall (A : Type) (a b : A), (a = b @ A) -> I -> A

// rec_I has the correct computational behavior

define rec_I_aux_zero :
  forall (A : Type) (a b : A) (p : a = b @ A),
     rec_I_aux A a b p zero == (a, idpath a) @ (singleton A a)
  :=
    fun A a b p =>
      handle
        trunc_comp bool (singleton A a) (singleton_is_prop A a) 
        (fun (c : bool) => cond (singleton A a) c (b, p) (a, idpath a))
        false
      with
        cond_false (singleton A a) (b, p) (a, idpath a)
      end
*)