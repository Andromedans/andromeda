(* Definition of propositional truncation from the Book. *)

Definition Type := Universe f0.

(* The type former *)
Parameter Trunc : Type -> Type.

(* Definition of something being a (-1)-type *)

Definition is_prop := fun (A : Type) => forall (x y : A), x = y.

(* The type constructors for propositional truncation *)

Parameter trunc : forall (A : Type), A -> Trunc A.

Parameter Trunc_is_prop : forall (A : Type), is_prop (Trunc A).

(* The non-dependent eliminator *)

Parameter rec_trunc :
  forall (A B : Type), is_prop B -> (A -> B) -> (Trunc A -> B).

(* The computation rule for trunc_elim *)

Parameter trunc_comp :
  forall (A B : Type)
         (p : is_prop B)
         (f : A -> B)
         (x : A),
    rec_trunc A B p f (trunc A x) == f x.

(* Contractible types *)

(* Got stuck here because there are no sigmas anymore. *)

Definition is_contr :=
   fun (A : Type) => (x : A) * ((y : A) -> (x = y @ A)) ;;

// If A is an inhabited proposition then it is contractible

define inhab_prop_is_contr :=
  fun (A : Type) (p : is_prop A) (a : A) =>
  ((a, (fun (b : A) => p a b)) :> is_contr A)

// Concatentaion and opposite paths
define opp :=
  fun (A : Type) (a b : A) (q : a = b @ A) =>
         Ind (q, x . y . p . (y = x @ A), z . idpath z)

define concat :=
  fun (A : Type) (a b c : A) (r : a = b @ A) (s : b = c @ A) =>
       Ind (r,
            x . y . p . (d : A) -> (q : y = d @ A ) -> (x = d @ A),
            z . fun (d : A) (q : z = d @ A) => q)
           c s

// If A is contractible then it is a proposition:

define contr_is_inhab_prop :=
  fun (A : Type) (c : is_contr A) =>
    (c.1 , 
     (fun (x y : A) => concat A x c.1 y (opp A c.1 x (c.2 x)) (c.2 y))) :> A * is_prop A
  
// Now we show that the truncation of booleans is the interval

// First we need the booleans

assume bool : Type
assume true false : bool
assume cond : (A : QuasiType 1) -> bool -> A -> A -> A

assume cond_true  : (A : QuasiType 1) -> (a : A) -> (b : A) -> cond A true a b == a @ A
assume cond_false : (A : QuasiType 1) -> (a : A) -> (b : A) -> cond A false a b == b @ A

assume ind_bool : (P : bool -> QuasiType 1) -> P false -> P true -> (b : bool) -> P b

// We need transport

define tr :=
  (fun (A : Type) (P : A -> Type) (a b : A) (s : a = b @ A) (u : P a) =>
    Ind (s, 
         x . y . p . (P x -> P y), 
         z . (fun v : P z => v)) u)
  :>
  forall (A : Type) (P : A -> Type) (a b : A) (s : a = b @ A), P a -> P b

// How to prove that two elements of a sigma type are equal

define total_path :
  forall (A : Type) (P : A -> Type) (a : A) (u : P a) (b : A) (v : P b) (p : a = b @ A),
    (tr A P a b p u = v @ P b) -> (a, u) = (b, v) @ ((x : A) * P x)
  :=
  fun A P a u b v p q =>
    Ind (p,
         x . y . s .
           (forall (u : P x) (v : P y) (q : tr A P x y s u = v @ P y),
             (x, u) = (y, v) @ ((x : A) * P x)),
         z . (fun (u v : P z) (q : u = v @ P z) =>
              Ind (q,
                   u . v . q . (z, u) = (z, v) @ ((x : A) * P x),
                   w . idpath ((z, w) :> ((x : A) * P x))
                  ))
        ) u v q

// We need singletons

define singleton := 
  fun (A : Type) (x : A) => exists (y : A), x = y @ A ;;

// TO DO
assume singleton_is_prop : forall (A : Type) (x : A), is_prop (singleton A x)
    
// Now we define the interval, but we only consider the non-dependent eliminator

define I := Trunc bool
define zero := trunc bool false
define one := trunc bool true
define seg := Trunc_is_prop bool zero one

// auxiliary definition
define rec_I_aux :
  forall (A : Type) (a b : A), (a = b @ A) -> I -> singleton A a
  :=
  fun A a b p =>
     rec_trunc bool (singleton A a) (singleton_is_prop A a)
                      (fun (c : bool) => cond (singleton A a) c (b, p) (a, idpath a))

define rec_I :=
   (fun A a b p x => (rec_I_aux A a b p x).1)
   :> 
   forall (A : Type) (a b : A), (a = b @ A) -> I -> A

// rec_I has the correct computational behavior

define rec_I_aux_zero :
  forall (A : Type) (a b : A) (p : a = b @ A),
     rec_I_aux A a b p zero == (a, idpath a) @ (singleton A a)
  :=
    fun A a b p =>
      handle
        trunc_comp bool (singleton A a) (singleton_is_prop A a) 
        (fun (c : bool) => cond (singleton A a) c (b, p) (a, idpath a))
        false
      with
        cond_false (singleton A a) (b, p) (a, idpath a)
      end
