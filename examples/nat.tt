let equiv := val fun X => 
 (match X with
 | [e1, e2, t] => 
     (match e1 = e2 with
     | true => val []
     | false => 
         let t2 = val whnf t  in
         match t2 with
         | _ == _  => val []
         /*
         | t`unit`              -> val []
         | t`forall ?t21, ?t22` ->
                 \lambda x : t21, equiv [e1 `x`, e2 `x`, t22 `x`]
         | _ -> let e3 = whnf e1  in
                let e4 = whnf e2  in
                match e3 = e4 with
                | true  -> val []
                | false -> 
                    match [e3,e4] with
                    | [`?f1 ?a1`, `?f2 ?a2`] ->
                          let [ws, 
          */      
         | _ => op EQUIV X
         end
     end
     )
 | _ => op EQUIV X
 end)

define Set := `Universe f0`
assume N : t`Set`
assume 0 : t`N`
assume S : t`N -> N`
assume N_ind : t`
    forall (P : N -> Set),
      P 0 ->
      (forall n : N, P n -> P (S n)) ->
      forall (m : N), P m
    `
assume N_ind_0 : t`
    forall 
      (P : N -> Set) 
      (z : P 0)
      (f : forall n : N, P n -> P (S n)),
      N_ind P z f 0 == z
    `

#context
assume N_ind_S :
  t`
    forall 
      (P : N -> Set) 
      (z : P 0)
      (f : forall n : N, P n -> P (S n))
      (m : N),
    N_ind P z f (S m) == f m (N_ind P z f m)
   `

// define id := `N_ind (fun _ : N => N)`

define id := 
   // makeApp variant
  `N_ind` `(fun _ : N => N)`

define plus :=
   `
    N_ind
      (fun _ : N => N -> N)
      (fun n : N => n) 
      (fun (n : N) (f : N -> N) (m : N) => S (f m))
   ` 


#context

