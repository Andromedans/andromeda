let equiv := val fun equiv(X) => 
  let _ = op print ["equiv",X]  in
  let fun eqspine (Y) =
    let _ = op print ["eqspine",Y] in
    match Y with
    | [e1,e2] when (e1 = e2) => 
        let _ = op print "alpha-equivalent"  in
        val []

    | [(forall e1, f1), (forall e2,f2)] =>
        let w1 = eqspine [e1,e2] in
        let _ = op print "forall domains ok" in
        let w2 =
          lambda x:e1,
            let e3 = f1 `x` in
            let e4 = f2 `x` in
            let e5 = val whnf e3 in
            let e6 = val whnf e4 in
            eqspine [e5, e6]  in
        val w1 ++ w2
    | _ => op EQUIV Y
    end  in
 (match X with
 | [e1, e2, t] => 
     (match e1 = e2 with
     | true => val []
     | false => 
         let t2 = val whnf t  in
         let _ = op print ["t2 = ", t2]  in

         match t2 with
         | _ == _  => val []
         | _ when (t2 = t`unit`) => val []
         | forall u1, u2 =>
               lambda x : t21, 
                 let a = e1 `x`  in
                 let b = e2 `x`  in
                 let c = u2 `x`  in
                 equiv [a,b,c]
         | _ => let e3 = val whnf e1  in
                let e4 = val whnf e2  in
                let _ = op print ["e3 =", e3, " e4 = ", e4]  in
                match e3 = e4 with
                | true  => val []
                | false => eqspine [e3,e4]
                end
         end
     end
     )
 | _ => op EQUIV X
 end)

define Set := val `Universe f0`

assume N : val t`Set`
assume 0 : val t`N`
assume S : val t`N -> N`
assume N_ind : val t`
    forall (P : N -> Set),
      P 0 ->
      (forall n : N, P n -> P (S n)) ->
      forall (m : N), P m
    `
assume N_ind_0 : val t`
    forall 
      (P : N -> Set) 
      (z : P 0)
      (f : forall n : N, P n -> P (S n)),
      N_ind P z f 0 == z
    `

#context
assume N_ind_S :
  val t`
    forall 
      (P : N -> Set) 
      (z : P 0)
      (f : forall n : N, P n -> P (S n))
      (m : N),
    N_ind P z f (S m) == f m (N_ind P z f m)
   `

// define id := `N_ind (fun _ : N => N)`

define id := 
   // makeApp variant
  `N_ind` `(fun _ : N => N)`

define plus :=
   val `
    N_ind
      (fun _ : N => N -> N)
      (fun n : N => n) 
      (fun (n : N) (f : N -> N) (m : N) => S (f m))
   ` 


#context
