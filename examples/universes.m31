(* An attempt to formalize a hierachy of universes. *)

(* The type of all universe indices *)
constant index : Type

(* The partial ordering of universe indices *)

constant ( < ) : index → index → Type
constant lt-uip : ∏ (i j : index) (p q : i < j), p ≡ q
now etas = add_eta lt-uip

constant ( <= ) : index → index → Type
constant leq-uip : ∏ (i j : index) (p q : i <= j), p ≡ q
now etas = add_eta leq-uip

constant lt-leq : ∏ (i j : index), i < j → i <= j
constant lt-refl : ∏ i : index, i <= i

(* The universes form a family indexed by, well, index. *)
constant U : index → Type

(* If i < j then U i has a name u i j _ in U j *)
constant u : Π (i j : index), i < j → U j

(* The elements of a universe are names of types *)
constant El : Π (i : index), U i → Type

constant u-def : Π (i j : index) (p : i < j), El j (u i j p) ≡ U i  (* : Type *)

constant lift : ∏ (i j : index) (p : i <= j), U i → U j
constant lift-El :
   ∏ (i j : index) (p : i <= j) (a : U i), El j (lift i j p a) ≡ El i a

(* The following might be used to make people's brains happy(er) *)
(* constant lift-id : ∏ (i : index) (p : i <= i) (a : U i), lift i i p a ≡ a *)

(* Names of dependent products *)
constant pi : Π (i j k : index), i <= k → j <= k → ∏ (a : U i), (El i a → U j) → U k
constant pi-El :
   Π (i j k : index) (p : i <= k) (q : j <= k),
   ∏ (a : U i) (b : El i a → U j),
     El k (pi i j k p q a b) ≡ (Π (x : El i a), El j (b x))  (* : Type *)

(* To have something to work with we give ourselves a base type *)
constant Cow : Type

constant cow : Π (i : index), U i
constant cow-El: Π (i : index), El i (cow i) ≡ Cow  (* : Type *)

(* We do not want the user to worry about the indices so we
   do magic using handlers. *)

operation UU : judgment

(* A "temporary" "solution" *)
let prove-leq i j =
  assume p : i <= j in p

(* Reverse-engineer the name of a type with a proof that
   it is correctly reverse-engineered *)
let rec name-of-eq T j =
  match T with
  | ⊢ Cow => Some (cow-El j)
  | ⊢ El j _ => Some (refl T)
  | ⊢ El ?i ?a =>
      let p = prove-leq i j in
      Some (lift-El i j p a)
(*      
  | ⊢ (?x ≡ ?y) =>
      let A = typeof x in
      match name-of-eq A with
      | None => None
      | Some (⊢ ?ξ : El ?a ≡ _) => 
        let x' = convert x (symmetry ξ)
        and y' = convert y (symmetry ξ) in
        let α = (El_eq a x' y') in
        let β = convert_eq (x' ≡ y') ξ  in
        Some (transitivity α β)
      end
  | ⊢ Π (?x : ?A), ?B => 
      match name-of-eq A with
      | None => None
      | Some (⊢ ?ξ : El ?a ≡ _) => 
          match name-of-eq B with
          | None => None
          | Some (⊢ ?ξ2 : El ?b ≡ _) => 
             Some (El_pi a (λ (y : El a), b where x = y))
          end
      end
*)
  | ?J => 
    match whnf T with
    | ⊢ ?ζ : _ ≡ ?T' =>
      match T' with
      | T => None
      | _ => 
        match name-of-eq T' j with
        | Some (⊢ ?ξ : El j ?a ≡ _) =>
            let answer = tran Type (El j a) T' T ξ (symmetry ζ)  in
            Some answer
        | None => None
        end
      end
    end
  end

(* The name of a type *)
let name-of T i =
  match name-of-eq T i with
  | None => None
  | Some (⊢ _ : El _ ?a ≡ _) => Some a
  end

let universe-handler =
  handler

  | coerce (⊢ ?a : U ?i) (⊢ Type) => yield (Coercible (El i a))

  | coerce (⊢ ?T : Type) (⊢ U ?i) =>
    match name-of T i with
    | None => yield NotCoercible
    | Some ?a => yield (Coercible a)
    end

  | UU : None => 
    assume i : index in
    assume j : index in
    assume p : i < j in
      yield (u i j p)

  | UU : Some ?A =>
    match whnf A with
do
  with universe-handler handle
   let u0 = UU in
   let u1 = UU : u0 in
   let u2 = UU : u1 in
   let u3 = UU : u1 in
   (u0, u1, u2, u3)
