// Definition of propositional truncation from the Book.

// The type former
assume Trunc : Type -> Type ;;

//
// Definition of something being an 0-type
//

define is_prop := fun (A : Type) => (x : A) -> (y : A) -> (x = y @ A) ;;

// The type constructors for propositional truncation

assume trunc : (A : Type) -> A -> Trunc A ;;

assume Trunc_is_prop : (A : Type) -> is_prop (Trunc A) ;;

// The non-dependent eliminator

assume rec_trunc :
  (A : Type) -> (B : Type) -> is_prop B -> (A -> B) -> (Trunc A -> B) ;;

// The computation rule for trunc_elim

assume trunc_comp :
  (A : Type) -> (B : Type) -> (p : is_prop B) -> (f : A -> B) -> (x : A) ->
  (rec_trunc A B p f (trunc A x) == f x @ B) ;;

// Contractible types:

define is_contr := fun (A : Type) => (x : A) * ((y : A) -> (x = y @ A)) ;;

// If A is an inhabited proposition then it is contractible

define inhab_prop_is_contr :=
  fun (A : Type) (p : is_prop A) (a : A) =>
  ((a, (fun (b : A) => p a b)) :> is_contr A);;

// Concatentaion and opposite paths
define opp :=
  fun (A : Type) (a b : A) (q : a = b @ A) =>
         Ind (q, x . y . p . (y = x @ A), z . idpath z)

define concat :=
  fun (A : Type) (a b c : A) (r : a = b @ A) (s : b = c @ A) =>
       Ind (r,
            x . y . p . (d : A) -> (q : y = d @ A ) -> (x = d @ A),
            z . fun (d : A) (q : z = d @ A) => q)
           c s

// If A is contractible then it is a proposition:

define contr_is_inhab_prop :=
  fun (A : Type) (c : is_contr A) =>
    (c.1 , 
     (fun (x y : A) => concat A x c.1 y (opp A c.1 x (c.2 x)) (c.2 y))) :> A * is_prop A
  
// Now we show that the truncation of booleans is the interval

// First we need the booleans

assume bool : Type
assume true false : bool
assume cond : (A : QuasiType 1) -> bool -> A -> A -> A

assume cond_true  : (A : QuasiType 1) -> (a : A) -> (b : A) -> cond A true a b == a @ A
assume cond_false : (A : QuasiType 1) -> (a : A) -> (b : A) -> cond A false a b == b @ A

assume ind_bool : (P : bool -> QuasiType 1) -> P false -> P true -> (b : bool) -> P b

// We need transport

define tr :=
  fun (A : Type) (P : A -> Type) (a b : A) (s : a = b @ A) (u : P a) =>
    Ind (s, 
         x . y . p . (P x -> P y), 
         z . (fun v : P z => v)) u 

// How to prove that two elements of a sigma type are equal

define total_path := 
  (fun A P a b p u v q =>
    Ind (p,
         x . y . s . 
           (forall (u : P x) (v : P y) (q : tr A P x y s u = v @ P y),
             (x, u) = (y, v) @ ((x : A) * P x)),
         z . (fun (u v : P z) (q : u = v @ P z) =>
              Ind (q, u . v . q . (z, u) = (z, v) @ ((x : A) * P x), y . refl y))
        )
   ) :>
   forall (A : Type) (P : A -> Type) (a : A) (u : P a) (b : b) (v : P b) (p : a = b @ A),
       (q : tr A P a b p u = v @ P b) -> (a, u) = (b, v) @ ((x : A) * P x)
     
// We need singletons

define singleton := fun (A : Type) (x : A) => exists (y : A), x = y @ A

// TO DO
assume singleton_is_prop :
  forall (A : Type) (x : A), is_prop (singleton A x)
    
// Now we define the interval, but we only consider the non-dependent eliminator

define I := Trunc bool
define zero := trunc bool false
define one := trunc bool true
define seg := Trunc_is_prop bool zero one

// auxiliary definition
define foo :=
  (fun (A : Type) (a b : A) (p : a = b @ A) =>
     rec_trunc bool A (exists (x : A), ) _ (fun (b : bool) => cond _ b _ _)
  )


//define rec_I :=
//   (fun (A : Type) (a b : A) (p : a = b @ A) =>
//     rec_trunc bool A _ _ (fun (b : bool) => cond _ b _ _)
//   )
//   :> 
//     forall (A : Type) (a b : A), (a = b @ A) -> I -> A
