
#include_once "base.m31"
#include "utils.m31"

data (!!) 1 
let debug = fun x => print !! x

operation beta 1
operation hint 1
operation eta  1
operation whnf 1

(* local hints *)
data lbeta 1
data lhint 1
data leta  1
operation getbetas 0
operation gethints 0
operation getetas  0

(*
Matching works the following way:
we have a list (|- xs : As = maybe vs) of typed atoms with potential values, such that each atom may appear in the following types
we have a typed term (|- target : t) in which any of the atoms may appear
we have some value f
we have a typed term (|- e : te) which is being matched

we must find an instantiation of the xs such that t == te and target == e
such an instantiation is a list of vs
if we find it we return (Some (f vs))
otherwise we return None

Usually f is a term of type (forall xs : As, foo), but there's no reason it couldn't be a function or even something weird.

For instance a beta hint b : forall y : B, e1 ==[T] e2 gives us
- xs : As = [y : B]
- target : t = e1 : T
- f = b
matching with e : T gives us a witness of e == e2[??/y]
*)

(* assoc_update which fails to match if the value to update isn't already present *)
let assoc_update = fun x v lst =>
  let rec aux acc lst = match lst with
    | (x, _) :: ?lst => rev_append acc ((x, v) :: lst)
    | ?y :: ?lst => aux (y :: acc) lst
    end
  in aux [] lst

(* updates quants with values such that lhs matches rhs *)
let rec collector quants lhs rhs =
  (* is lhs an atom?
     NB it would be nice to have a matching primitive to know if some term is an atom. *)
  match assoc_find lhs quants with
    | Some None => (* not yet set atom *)
      let quants = assoc_update lhs (Some rhs) quants in
      Some quants
    | Some (Some ?lhs) => (* already set atom *)
      collector quants lhs rhs
    | None => (* not an atom *)
      match assoc_find rhs quants with
        | Some None =>
          let quants = assoc_update rhs (Some lhs) quants in
          Some quants
        | Some (Some ?rhs) =>
          collector quants lhs rhs
        | None =>
          match (lhs, rhs) with
            | (?a, ?a) => (* alpha equal *)
              Some quants
            | ((|- ?l1 ?l2), (|- ?r1 ?r2)) =>
              match collector quants l1 r1 with
                (* could there be something smarter to do in either failure case? *)
                | Some ?quants => collector quants l2 r2
                | None => None
              end
            | ((|- ?l1 == ?l2), (|- ?r1 == ?r2)) =>
              match collector quants l1 r1 with
                | Some ?quants => collector quants l2 r2
                | None => None
              end
            (* TODO add cases *)
            | _ => None
          end
      end
  end

let rec apply_quants f quants = match quants with
  | [] => Some f
  | (_, None) :: _ => None
  | (_, Some ?v) :: ?quants =>
    apply_quants (f v) quants
  end

let generic_matcher = fun pat e =>
  match pat with
    | (?f, (?quants, ?lhs)) =>
      match collector quants lhs e with
        | Some ?quants =>
          apply_quants f quants
        | None => None
      end
  end

(* A beta hint is a term e of type b == forall [xs], lhs == rhs.
   It is used by matching lhs against a term to be reduced,
   so all xs must appear in lhs (including the type??) *)
let process_beta =
  let rec deep quants e b = match b with
    | |- forall (?x : _), ?b =>
      deep ((x, None) :: quants) e b
    | |- ?lhs == _ => (e, (rev quants, lhs))
    end
  in
  fun b => match b with
    | |- ?e : ?b => deep [] e b
    end

(* A general hint is a term e of type h == forall [xs], lhs == rhs.
  It is used by matching lhs == rhs against an equality to be verified. *)
let process_hint =
  let rec deep quants e h = match h with
    | |- forall (?x : _), ?h =>
      deep ((x, None) :: quants) e h
    | |- _ == _ => (e, (rev quants, h))
    end
  in
  fun h => match h with
    | |- ?e : ?h => deep [] e h
    end

(* An eta hint is a term e of type t == forall [xs] [a b : T] [eqs : ?? == ??], a == b.
  It is used by matching T with the type of a target equality, then filling in a and b and solving the eqs.
  
  ie if we have an equation lhs ==[T'] rhs to solve through eta,
  - match T with T' to instantiate xs to vs
  - compute (e vs lhs rhs) to get a term of type forall [eqs], lhs == rhs
  - solve the eqs
  
  TODO allow eqs : forall [ys] ?? == ??
  This is necessary eg for funext (which has eq : forall x, f x == g x)
  *)
let process_eta =
  (* we have matched t with the general shape of an eta hint *)
  let finalize = fun e xs eqs a b =>
    let T = match a with |- _ : ?T => T end in
    let rec f e xs = match xs with
      | [] =>
        fun ea eb =>
        let e = e ea eb in
        (* now we have e : forall [eqs[ea,eb]], ea == eb and we need to solve the eqs *)
        let rec auto e = match e with
          | |- _ : forall (_ : ?lhs == ?rhs), _ =>
            match equal lhs rhs with
              | Some ?eq => auto (e eq)
              | None => None
            end
          | |- _ : _ == _ => Some e
          end
        in
        auto e
      | _ :: ?xs =>
        fun v => f (e v) xs
      end
    in
    (f e xs, (xs, T))
  in
  (* quants++(rev eqs) is the list [xs;a;b;eqs] in reverse order. We want to split it into [xs] and [eqs]. *)
  let rec quant_splitter e eqs quants a b =
    match quants with
      | (b, _) :: (a, _) :: ?xs =>
        let xs = rev xs in
        finalize e xs eqs a b
      | ?eq :: ?quants =>
        quant_splitter e (eq::eqs) quants a b
      | [] => let _ = print "Bad eta:" in let _ = print e in match [] with end
    end
  in
  let rec deep quants e h = match h with
    | |- forall (?x : _), ?h =>
      deep ((x, None) :: quants) e h
    | |- ?a == ?b =>
      quant_splitter e [] quants a b
    end
  in
  fun h => match h with
    | |- ?e : ?t => deep [] e t
    end

let sym = λ (A : Type, x y : A, h : x ≡ y), handle refl x : y ≡ x with
  | equal _ _ =>
    yield (Some h)
  end

let tran = lambda (t : Type) (a b c : t) (eq1 : a == b) (eq2 : b == c),
  handle eq2 : a == c with
    | equal ((|- a == c : _) as ?x) ((|- b == c : _) as ?y) => handle yield (congruence x y) with
      | equal a b => yield (Some eq1)
    end
  end

(* pick the rhs because it's more reduced in practice *)
let hide_witness = fun eq => match eq with
  |- _ : ?a == ?b => match a with |- _ : ?t =>
    handle refl b : a == b with equal b a => yield (Some (sym t a b eq)) end
  end end

(* implicit arguments and hide witness *)
let symmetry = fun eq =>
  match eq with
    |- _ : ?a == ?b =>
      match a with |- _ : ?t =>
        hide_witness (sym t a b eq)
      end
  end

let transitivity = fun eq1 eq2 =>
  match (eq1, eq2) with
    | ((|- _ : ?a == ?b), (|- _ : _ == ?c)) =>
      match a with |- _ : ?t =>
        hide_witness (tran t a b c eq1 eq2)
      end
  end

let unopt = fun v => match v with
  | Some ?v => v
  end

(* attempt to apply one of betas to e (not to a subterm of e) *)
let rec step_at betas e =
  match betas with
    | [] => None
    | ?b :: ?rem =>
      match generic_matcher b e with
        | (Some _) as ?m => m
        | None => step_at rem e
      end
  end

let rec hint_at hints e =
  match hints with
    | [] => None
    | ?h :: ?rem =>
      match generic_matcher h e with
        | (Some _) as ?m => m
        | None => hint_at rem e
      end
  end

let rec eta_at etas a b t =
  match etas with
    | [] => None
    | ?h :: ?rem =>
      match generic_matcher h t with
        | Some ?f => f a b
        | None => eta_at rem a b t
      end
  end


let rec do_whnf betas e =
  match e with
    | |- ?e1 ?e2 : ?t =>
      match do_whnf betas e1 with
        | Some (|- ?eq : _ == ?e1') =>
          (*
            At this point, [e2] has type [a] for some [a], and both [e1] and [e1'] have the same type [forall x : a, foo] such that [foo[e2/x] == t].
            However if that equality is difficult to derive the following ascription may do something undesired or fail.
            Therefore in the future it may be better to explicitly do
            match equal foo[e2/x] t with
              | Some ?eqt => use eqt in (e1' e2) : t
              | None => fail
            end
            
            The other option would be to have unicity of typing primitives which,
            given a judgement (ctx |- e : t) derives a type t' from the annotations of e and from ctx such that (ctx |- e : t'),
            and then return ctx |- refl t : t == t' and ctx |- e : t'
            
            then t' would be foo[e2/x] for both (e1 e2) and (e1' e2), problem solved (because e1, e1' : forall x : A, foo)
          *)
          let e' = e1' e2 in
          let e' = e' : t in
          let meq = handle congruence e e' with
            | equal e1 e1' => yield (Some eq)
            end
          in
          let eq = match meq with
              | Some ?eq => eq : e == e'
            end
          in
          match do_whnf betas e' with
            | Some (|- ?eq' : _ == ?e'') =>
              let eq = transitivity eq eq' in
              Some eq
            | None => Some eq
          end
        | None =>
          match reduce e with
            | Some (|- ?eq : _ == ?e') =>
              match do_whnf betas e' with
                | Some (|- ?eq' : _ == ?e'') =>
                  let eq = transitivity eq eq' in
                  Some eq
                | None => Some eq
              end
            | None =>
              (* e1 is in whnf and e is not a beta redex, so we only need to see if a beta hint applies to e *)
              match step_at betas e with
                | Some (|- ?eq : _ == ?e') =>
                      match do_whnf betas e' with
                    | Some (|- ?eq' : _ == ?e'') =>
                      let eq = transitivity eq eq' in
                      Some eq
                    | None =>
                      Some eq
                  end
                | None => None
              end
          end
      end
    | |- _ : ?t =>
      match step_at betas e with
        | Some (|- ?eq : _ == ?e') =>
          match do_whnf betas e' with
            | Some (|- ?eq' : _ == ?e'') =>
              let eq = transitivity eq eq' in
              Some eq
            | None => Some eq
          end
        | None =>
          None
          (* TODO are there any non application cases where we need to reduce a subterm?
             Projections but we can't match them yet. *)
      end
  end

let whnf_eq = fun betas e =>
match do_whnf betas e with
  | Some ?eq => eq
  | None => refl e
  end


let rec equate_congr a b =
  let betas = getbetas in
  match (whnf_eq betas a, whnf_eq betas b) with
    ((|- ?eqa : _ == ?a'), (|- ?eqb : _ == ?b')) =>
      let r = match (a', b') with
        | ((|- ?a1 ?a2), (|- ?b1 ?b2)) =>
          (* TODO figure out how not to loop on etas without full equate_congr *)
          handle congruence a' b' with
            equal a2 b2 => yield (equate_congr a2 b2)
          end
        | _ => congruence a' b'
        end
      in
      match r with
        | Some ?eq =>
          let eq = transitivity eqa (transitivity eq (symmetry eqb)) in
          Some eq
        | None => None
      end
  end

let rec equate x y =
  (* x and y must have the same derived type *)
  let t = match (x, y) with ((|- _ : ?t), (|- _ : ?t)) => t end in
  match hint_at gethints (x == y) with
    | None =>
      match (handle eta_at getetas x y t with equal ?a ?b => yield (equate a b) end) with
        | Some ?eq => Some eq
        | None =>
          handle equate_congr x y with equal ?a ?b => yield (equate a b) end
      end
    | Some ?eq => Some eq
  end


let hint_provider = fun betas hints etas => handler
  | getbetas => yield betas
  | gethints => yield hints
  | getetas => yield etas
  end

(* we return the betas and hints so that we may reuse them. eg
let comp1 = with equality betas hints handle (foo ... add_beta b ... baz)
let v = match comp1 with (?v, _) => v end
let betas = match comp1 with (_, (?betas, _)) => betas
let hints = ...

let comp2 = with equality betas hints handle ...
...

then in comp2 the hint b is available
*)
let rec equality betas hints etas = handler
  | equal (|- ?a : ?t) ?b (* : ?t *) => fun betas hints etas =>
    let r = (with hint_provider betas hints etas handle equate a b) in
    yield r betas hints etas

  | whnf ?e => fun betas hints =>
    match (with equality betas hints etas handle whnf_eq betas e) with
      | (?eq, (?betas :: ?hints :: ?etas :: [])) =>
        yield eq betas hints etas
    end

  | beta ?b => fun betas hints etas =>
    let b = process_beta b in
    yield () (b :: betas) hints etas

  | hint ?h => fun betas hints etas =>
    let h = process_hint h in
    yield () betas (h :: hints) etas

  | eta ?h => fun betas hints etas =>
    let h = process_eta h in
    yield () betas hints (h::etas)

  | getbetas => fun betas hints etas =>
    yield betas betas hints etas

  | gethints => fun betas hints etas =>
    yield hints betas hints etas

  | getetas => fun betas hints etas =>
    yield etas betas hints etas

(* TODO | as_* *)

  | val ?v => fun betas hints etas => (v, betas :: hints :: etas :: [])

  | finally ?f => f betas hints etas
  end



(* doesn't return the state *)
let equality_in = fun betas hints etas => handler
  | equal (|- ?a : ?t) ?b (* : ?t *) => fun betas hints etas =>
    match (with equality betas hints etas handle equal a b) with
      | (?v, ?betas :: ?hints :: ?etas :: []) => yield v betas hints etas
    end

  | whnf ?e => fun betas hints etas =>
    match (with equality betas hints etas handle whnf_eq betas e) with
      | (?v, ?betas :: ?hints :: ?etas :: []) => yield v betas hints etas
    end

  | beta ?b => fun betas hints etas =>
    match (with equality betas hints etas handle beta b) with
      | (?v, ?betas :: ?hints :: ?etas :: []) => yield v betas hints etas
    end

  | hint ?h => fun betas hints etas =>
    match (with equality betas hints etas handle hint h) with
      | (?v, ?betas :: ?hints :: ?etas :: []) => yield v betas hints etas
    end

  | eta ?h => fun betas hints etas =>
    match (with equality betas hints etas handle eta h) with
      | (?v, ?betas :: ?hints :: ?etas :: []) => yield v betas hints etas
    end

  | getbetas => fun betas hints etas =>
    match (with equality betas hints etas handle getbetas) with
      | (?v, ?betas :: ?hints :: ?etas :: []) => yield v betas hints etas
    end

  | gethints => fun betas hints etas =>
    match (with equality betas hints etas handle gethints) with
      | (?v, ?betas :: ?hints :: ?etas :: []) => yield v betas hints etas
    end

  | getetas => fun betas hints etas =>
    match (with equality betas hints etas handle getetas) with
      | (?v, ?betas :: ?hints :: ?etas :: []) => yield v betas hints etas
    end

  | val ?v => fun betas hints etas => v

  | finally ?f => f betas hints etas
  end

(* TODO split into lbeta|lhint|... functions *)
let local = fun action =>
  let betas = getbetas and hints = gethints and etas = getetas in
  match (with equality betas hints etas handle
    match action with
      | lbeta ?b => beta b
      | lhint ?h => hint h
      | leta  ?h => eta  h
    end) with
    | (_, ?betas :: ?hints :: ?etas :: []) =>
      equality_in betas hints etas
  end

let top_betas = ref []
let top_hints = ref []
let top_etas  = ref []

(* top level handler with no hints *)
handle
  | equal a b =>
    with equality_in !top_betas !top_hints !top_etas handle equal a b

  | whnf e =>
    with equality_in !top_betas !top_hints !top_etas handle whnf e

  | as_prod e =>
    match (with equality_in !top_betas !top_hints !top_etas handle whnf e) with
      | |- ?eq : _ == (forall (_ : _), _) => Some eq
      | _ => None
    end

  | as_eq e =>
    match (with equality_in !top_betas !top_hints !top_etas handle whnf e) with
      | |- ?eq : _ == (_ == _) => Some eq
      | _ => None
    end

  | as_signature e => (* TODO no good way to match generic signature *)
    with equality_in !top_betas !top_hints !top_etas handle whnf e

  | beta b =>
    match (with equality !top_betas !top_hints !top_etas handle beta b) with
      | (_, ?betas :: ?hints :: ?etas :: []) =>
        top_betas := betas
    end

  | hint h =>
    match (with equality !top_betas !top_hints !top_etas handle hint h) with
      | (_, ?betas :: ?hints :: ?etas :: []) =>
        top_hints := hints
    end

  | eta h =>
    match (with equality !top_betas !top_hints !top_etas handle eta h) with
      | (_, ?betas :: ?hints :: ?etas :: []) =>
        top_etas := etas
    end

  | getbetas =>
    !top_betas

  | gethints =>
    !top_hints

  | getetas =>
    !top_etas
end

(* helper functions *)
let add_beta = fun b =>
  match with equality !top_betas !top_hints !top_etas handle beta b with
    | (_, ?betas :: _ :: _ :: []) => top_betas := betas
  end

let add_hint = fun h =>
  match with equality !top_betas !top_hints !top_etas handle hint h with
    | (_, _ :: ?hints :: _ :: []) => top_hints := hints
  end

let add_eta = fun h =>
  match with equality !top_betas !top_hints !top_etas handle eta h with
    | (_, _ :: _ :: ?etas :: []) => top_etas := etas
  end

