#include_once "base.m31"
#include "utils.m31"

(* Poor man's debugging mechanism. *)
data (!!) 1 
let debug = fun x => print !! x

(* Operations for installing equality hints *)
operation beta 1  (* Install a beta hint *)
operation hint 1  (* Install a general hint *)
operation eta  1  (* Install an eta hint *)

(* Operations for installing local hints *)
data lbeta 1
data lhint 1
data leta  1

operation whnf 1  (* Compute the weak head normal form *)

(* These return a list of hints in a preprocessed form, see process_xyz *)
operation getbetas 0 (* Get the current beta hints *)
operation gethints 0 (* Get the current general hints *)
operation getetas  0 (* Get the current eta hints *)

(* One of the tasks we need to be able to do is this: given a universally quantified type
   `∏(x1:A1)...(xn:An) B` and a type `C`, find an instantiation `x1↦e1, ..., xn↦en` such that
   `B[x1↦e1, ..., xn↦en]` equals `C`. Of course, everything has to be well-typed etc.

   We provide here functions that solve this task, and in fact work more generally:
   given a term `b` and atoms `x1:A1, ..., xn:An`, find an instantiation of the atoms
   that will make b equal to a given term `c`.

   We build the instantiation in steps. A partial instantiation below is called
   `quants`. It is an associative list which maps an atom `x` to either `None` or `Some t`
   where `t` is the instantiation for `x`.
*)

(*
Matching works the following way:
we have a list (|- xs : As = maybe vs) of typed atoms with potential values, such that each atom may appear in the following types
we have a typed term (|- target : t) in which any of the atoms may appear (as well as other atoms)
we have some value f
we have a typed term (|- e : te) which is being matched

we must find an instantiation of the xs such that t == te and target == e
such an instantiation is a list of vs
if we find it we return (Some (f vs))
otherwise we return None

Usually f is a term of type (forall xs : As, foo), but there's no reason it couldn't be a function or even something weird.

For instance a beta hint b : forall y : B, e1 ==[T] e2 gives us
- xs : As = [y : B]
- target : t = e1 : T
- f = b
matching with e : T gives us a witness of e == e2[??/y]
*)

let (>?=) = fun m f => match m with
  | Some ?x => f x
  | None => None
  end

(* TODO deal with rigids *)
(* Update `quants` with values such that `lhs` matches `rhs`. 
   Return updated `Some quants`, or `None` if `lhs` could not
   be made to match `rhs`.

   If `Some quants` is returned then `lhs` instantiated with
   `quants` will be equal to `rhs` instantiated with `quants`.
*)
let rec collector quants lhs rhs =
  (* is lhs an atom?
     NB it would be nice to have a matching primitive to know if some term is an atom. 
  *)
  match assoc_find lhs quants with
    | Some None => (* not yet set atom *)
      let quants = assoc_update lhs (Some rhs) quants in
      Some quants
    | Some (Some ?lhs) => (* already set atom *)
      collector quants lhs rhs
    | None => (* not an atom *)
      match assoc_find rhs quants with
        | Some None =>
          let quants = assoc_update rhs (Some lhs) quants in
          Some quants
        | Some (Some ?rhs) =>
          collector quants lhs rhs
        | None =>
          match (lhs, rhs) with
            | (?a, ?a) => (* alpha equal *)
              Some quants

            | ((|- lambda (?x1 : ?a1), ?e1), (|- lambda (?x2 : ?a2), ?e2)) =>
              match (e1, e2) with
                ((|- _ : ?b1), (|- _ : ?b2)) =>
                  collector quants a1 a2 >?= (fun quants =>
                  let quants = (x2, (Some x1)) :: quants in
                  collector quants b1 b2 >?= (fun quants =>
                  collector quants e1 e2 >?= (fun quants =>
                  let quants = match quants with (x2, (Some x1)) :: ?quants => quants end in
                  Some quants)))
              end

            | ((|- ?l1 ?r1), (|- ?l2 ?r2)) =>
              (* extract annotations *)
              match (l1, l2) with
                ((|- _ : forall (?x1 : ?a1), ?b1), (|- _ : forall (?x2 : ?a2), ?b2)) =>
                  collector quants a1 a2 >?= (fun quants =>
                  let quants = (x2, (Some x1)) :: quants in
                  collector quants b1 b2 >?= (fun quants =>
                  let quants = match quants with (x2, (Some x1)) :: ?quants => quants end in
                  collector quants l1 l2 >?= (fun quants =>
                  collector quants r1 r2)))
              end

            | ((|- forall (?x1 : ?a1), ?b1), (|- forall (?x2 : ?a2), ?b2)) =>
              collector quants a1 a2 >?= (fun quants =>
              let quants = (x2, (Some x1)) :: quants in
              collector quants b1 b2 >?= (fun quants =>
              let quants = match quants with (x2, (Some x1)) :: ?quants => quants end in
              Some quants))

            | ((|- ?l1 == ?r1), (|- ?l2 == ?r2)) =>
              match (l1, l2) with
                ((|- _ : ?t1), (|- _ : ?t2)) =>
                  collector quants t1 t2 >?= (fun quants =>
                  collector quants l1 l2 >?= (fun quants =>
                  collector quants r1 r2))
              end

            | ((|- refl ?e1), (|- refl ?e2)) =>
              match (e1, e2) with
                ((|- _ : ?t1), (|- _ : ?t2)) =>
                  collector quants t1 t2 >?= (fun quants =>
                  collector quants e1 e2)
              end

            (* TODO structures *)
            | _ => None
          end
      end
  end

(* Given `(x1, Some v1), ..., (xn, Some vn)` apply `f` to the
   values `v1, ..., vn` and return `Some (f v1 ... vn)`.
   If any of the `Some vi` is `None`, fail by returning `None`.
*)
let rec apply_quants f quants = match quants with
  | [] => Some f
  | (_, None) :: _ => None
  | (_, Some ?v) :: ?quants =>
    apply_quants (f v) quants
  end

let generic_matcher = fun pat e =>
  match pat with
    | (?f, (?quants, ?lhs)) =>
      match collector quants lhs e with
        | Some ?quants =>
          apply_quants f quants
        | None => None
      end
  end

(* A beta hint is a term `e` whose type is a universally quantified equations
   `∏ (x1:A1) ... (xn:An), lhs == rhs`. It is used by matching `lhs` against a term
   to be reduced to the instantiated `rhs`.

   If the instantiation of `x1, .., xn` cannot be read off `lhs` (because not all the
   `x1, ..., xn` appear in it) then the beta hint will fail later on.
*)
let process_beta =
  let rec deep quants e b = match b with
    | |- forall (?x : _), ?b =>
      deep ((x, None) :: quants) e b
    | |- ?lhs == _ => (e, (rev quants, lhs))
    end
  in
  fun e => match e with
    | |- ?e : ?b => deep [] e b
    end

(* A general hint is a term `e` of type `forall [xs], lhs == rhs`.
  It is used by matching `lhs == rhs` against an equality to be verified. *)
let process_hint =
  let rec deep quants e h = match h with
    | |- forall (?x : _), ?h =>
      deep ((x, None) :: quants) e h
    | |- _ == _ => (e, (rev quants, h))
    end
  in
  fun h => match h with
    | |- ?e : ?h => deep [] e h
    end

(* An eta hint is a term `e` of type `forall [xs] [a b : T] [eqs : ?? == ??], a == b`. It
  is used by matching `T` with the type of a target equality, then filling in `a` and `b`
  and solving the `eqs`.
  
  If we have an equation `lhs == rhs` at type `T'` to solve through eta:
  * match `T` with `T'` to instantiate `xs` to `vs`
  * compute `e vs lhs rhs` to get a term of type `forall [eqs], lhs == rhs`
  * solve the `eqs`
  
  TODO allow `eqs : forall [ys] ?? == ??`
  This is necessary eg for `funext` (which has `eq : forall x, f x == g x`)
*)
let process_eta =
  (* we have matched t with the general shape of an eta hint *)
  let finalize = fun e xs eqs a b =>
    let T = match a with |- _ : ?T => T end in
    let rec f e xs = match xs with
      | [] =>
        fun ea eb =>
        let e = e ea eb in
        (* now we have e : forall [eqs[ea,eb]], ea == eb and we need to solve the eqs *)
        let rec auto e = match e with
          | |- _ : forall (_ : ?lhs == ?rhs), _ =>
            match equal lhs rhs with
              | Some ?eq => auto (e eq)
              | None => None
            end
          | |- _ : _ == _ => Some e
          end
        in
        auto e
      | _ :: ?xs =>
        fun v => f (e v) xs
      end
    in
    (f e xs, (xs, T))
  in
  (* quants++(rev eqs) is the list [xs;a;b;eqs] in reverse order. We want to split it into [xs] and [eqs]. *)
  let rec quant_splitter e eqs quants a b =
    match quants with
      | (b, _) :: (a, _) :: ?xs =>
        let xs = rev xs in
        finalize e xs eqs a b
      | ?eq :: ?quants =>
        quant_splitter e (eq::eqs) quants a b
      | [] => let _ = print "Bad eta:" in let _ = print e in match [] with end
    end
  in
  let rec deep quants e h = match h with
    | |- forall (?x : _), ?h =>
      deep ((x, None) :: quants) e h
    | |- ?a == ?b =>
      quant_splitter e [] quants a b
    end
  in
  fun h => match h with
    | |- ?e : ?t => deep [] e t
    end

(* The term witnessing symmetry of equality. *)
let sym = λ (A : Type, x y : A, h : x ≡ y), handle refl x : y ≡ x with
  | equal _ _ =>
    yield (Some h)
  end

(* The term witnessing transitivity of equality *)
let tran = lambda (t : Type) (a b c : t) (eq1 : a == b) (eq2 : b == c),
  handle eq2 : a == c with
    | equal ((|- a == c : _) as ?x) ((|- b == c : _) as ?y) => handle yield (congruence x y) with
      | equal a b => yield (Some eq1)
    end
  end

(* Take `p : a == b` and return `refl b : a == b`. This is used to make
   witnesses of equalities small. *)
let hide_witness = fun eq => match eq with
  |- _ : ?a == ?b => match a with |- _ : ?t =>
    handle refl b : a == b with equal b a => yield (Some (sym t a b eq)) end
  end end

(* Take `p : a == b` and return `refl a : b == a`. This is used instead
   of `sym` to keep witnesses of equality small. *)
let symmetry = fun eq =>
  match eq with
    |- _ : ?a == ?b =>
      match a with |- _ : ?t =>
        hide_witness (sym t a b eq)
      end
  end

(* As `symmetry` but for transitivity. *)
let transitivity = fun eq1 eq2 =>
  match (eq1, eq2) with
    | ((|- _ : ?a == ?b), (|- _ : _ == ?c)) =>
      match a with |- _ : ?t =>
        hide_witness (tran t a b c eq1 eq2)
      end
  end

(* Attempt to apply one of `betas` to a term `e`. Here `betas` is a list of beta hints previously
   processed by `process_beta`. Return `Some (⊢ p : e == e')` or `None` if no hint applies. *)
let rec step_at betas e =
  match betas with
    | [] => None
    | ?b :: ?rem =>
      match generic_matcher b e with
        | (Some _) as ?m => m
        | None => step_at rem e
      end
  end

(* Attempt to apply one of general `hints` to an equation `e`. Return `Some (⊢ p : e)` or
   `None` if no hint applies. *)
let rec hint_at hints e =
  match hints with
    | [] => None
    | ?h :: ?rem =>
      match generic_matcher h e with
        | (Some _) as ?m => m
        | None => hint_at rem e
      end
  end

(* Attempt to apply one of `etas` to equation `a == b` at type `t`. It will trigger further
   operations that try to solve the resulting subproblems. Return `Some (⊢ p : a == b)` on
   success, or `None` otherwise. *)
let rec eta_at etas a b t =
  match etas with
    | [] => None
    | ?h :: ?rem =>
      match generic_matcher h t with
        | Some ?f => f a b
        | None => eta_at rem a b t
      end
  end

(* Compute the weak head normal form of a term `e` using the `betas` hints.
   Return `Some (⊢ p : e == e')` where `e'` is the normal form, or `None` if
   `e` is already normal. *)
let rec do_whnf betas e =
  match e with
    | |- ?e1 ?e2 : ?t =>
      match do_whnf betas e1 with
        | Some (|- ?eq : _ == ?e1') =>
          (*
            At this point, [e2] has type [a] for some [a], and both [e1] and [e1'] have the same type [forall x : a, foo] such that [foo[e2/x] == t].
            However if that equality is difficult to derive the following ascription may do something undesired or fail.
            Therefore in the future it may be better to explicitly do
            match equal foo[e2/x] t with
              | Some ?eqt => use eqt in (e1' e2) : t
              | None => fail
            end
            
            The other option would be to have unicity of typing primitives which,
            given a judgement (ctx |- e : t) derives a type t' from the annotations of e and from ctx such that (ctx |- e : t'),
            and then return ctx |- refl t : t == t' and ctx |- e : t'
            
            then t' would be foo[e2/x] for both (e1 e2) and (e1' e2), problem solved (because e1, e1' : forall x : A, foo)
          *)
          let e' = e1' e2 in
          let e' = e' : t in
          let meq = handle congruence e e' with
            | equal e1 e1' => yield (Some eq)
            end
          in
          let eq = match meq with
              | Some ?eq => eq : e == e'
            end
          in
          match do_whnf betas e' with
            | Some (|- ?eq' : _ == ?e'') =>
              let eq = transitivity eq eq' in
              Some eq
            | None => Some eq
          end
        | None =>
          match reduce e with
            | Some (|- ?eq : _ == ?e') =>
              match do_whnf betas e' with
                | Some (|- ?eq' : _ == ?e'') =>
                  let eq = transitivity eq eq' in
                  Some eq
                | None => Some eq
              end
            | None =>
              (* e1 is in whnf and e is not a beta redex, so we only need to see if a beta hint applies to e *)
              match step_at betas e with
                | Some (|- ?eq : _ == ?e') =>
                      match do_whnf betas e' with
                    | Some (|- ?eq' : _ == ?e'') =>
                      let eq = transitivity eq eq' in
                      Some eq
                    | None =>
                      Some eq
                  end
                | None => None
              end
          end
      end
    | |- _ : ?t =>
      match step_at betas e with
        | Some (|- ?eq : _ == ?e') =>
          match do_whnf betas e' with
            | Some (|- ?eq' : _ == ?e'') =>
              let eq = transitivity eq eq' in
              Some eq
            | None => Some eq
          end
        | None =>
          None
          (* TODO are there any non application cases where we need to reduce a subterm?
             Projections but we can't match them yet. *)
      end
  end

(* Like `do_whnf betas e` except that it always returns the witness of equality between
   `e` and its normal form (so reflexivity if `e` is normal). *)
let whnf_eq = fun betas e =>
match do_whnf betas e with
  | Some ?eq => eq
  | None => refl e
  end

(* Structurally compare the whnf of `a` and `b`. Return `Some (⊢ p : a == b)` on
   success, otherwise `None`. It will trigger general equality problems on subterms. *)
let rec equate_congr a b =
  let betas = getbetas in
  match (whnf_eq betas a, whnf_eq betas b) with
    ((|- ?eqa : _ == ?a'), (|- ?eqb : _ == ?b')) =>
      match congruence a' b' with
        | Some ?eq =>
          let eq = transitivity eqa (transitivity eq (symmetry eqb)) in
          Some eq
        | None => None
      end
  end

(* Try to show that [x] and [y] are equal by applying in succession:
   general hints, eta hints, and structural equality. *)
let rec equate x y =
  (* x and y must have the same derived type *)
  let t = match (x, y) with ((|- _ : ?t), (|- _ : ?t)) => t end in
  match hint_at gethints (x == y) with
    | None =>
      match (handle eta_at getetas x y t with equal ?a ?b => yield (equate a b) end) with
        | Some ?eq => Some eq
        | None =>
          handle equate_congr x y with equal ?a ?b => yield (equate a b) end
      end
    | Some ?eq => Some eq
  end

let hint_provider = fun betas hints etas => handler
  | getbetas => yield betas
  | gethints => yield hints
  | getetas => yield etas
  end

(* we return the betas and hints so that we may reuse them. eg
let comp1 = with equality betas hints handle (foo ... add_beta b ... baz)
let v = match comp1 with (?v, _) => v end
let betas = match comp1 with (_, (?betas, _)) => betas
let hints = ...

let comp2 = with equality betas hints handle ...
...

then in comp2 the hint b is available
*)
let rec equality betas hints etas = handler
  | equal (|- ?a : ?t) ?b (* : ?t *) => fun betas hints etas =>
    let r = (with hint_provider betas hints etas handle equate a b) in
    yield r betas hints etas

  | whnf ?e => fun betas hints =>
    match (with equality betas hints etas handle whnf_eq betas e) with
      | (?eq, (?betas :: ?hints :: ?etas :: [])) =>
        yield eq betas hints etas
    end

  | beta ?b => fun betas hints etas =>
    let b = process_beta b in
    yield () (b :: betas) hints etas

  | hint ?h => fun betas hints etas =>
    let h = process_hint h in
    yield () betas (h :: hints) etas

  | eta ?h => fun betas hints etas =>
    let h = process_eta h in
    yield () betas hints (h::etas)

  | getbetas => fun betas hints etas =>
    yield betas betas hints etas

  | gethints => fun betas hints etas =>
    yield hints betas hints etas

  | getetas => fun betas hints etas =>
    yield etas betas hints etas

(* TODO | as_* *)

  | val ?v => fun betas hints etas => (v, betas :: hints :: etas :: [])

  | finally ?f => f betas hints etas
  end



(* doesn't return the state *)
let equality_in = fun betas hints etas => handler
  | equal (|- ?a : ?t) ?b (* : ?t *) => fun betas hints etas =>
    match (with equality betas hints etas handle equal a b) with
      | (?v, ?betas :: ?hints :: ?etas :: []) => yield v betas hints etas
    end

  | whnf ?e => fun betas hints etas =>
    match (with equality betas hints etas handle whnf_eq betas e) with
      | (?v, ?betas :: ?hints :: ?etas :: []) => yield v betas hints etas
    end

  | beta ?b => fun betas hints etas =>
    match (with equality betas hints etas handle beta b) with
      | (?v, ?betas :: ?hints :: ?etas :: []) => yield v betas hints etas
    end

  | hint ?h => fun betas hints etas =>
    match (with equality betas hints etas handle hint h) with
      | (?v, ?betas :: ?hints :: ?etas :: []) => yield v betas hints etas
    end

  | eta ?h => fun betas hints etas =>
    match (with equality betas hints etas handle eta h) with
      | (?v, ?betas :: ?hints :: ?etas :: []) => yield v betas hints etas
    end

  | getbetas => fun betas hints etas =>
    match (with equality betas hints etas handle getbetas) with
      | (?v, ?betas :: ?hints :: ?etas :: []) => yield v betas hints etas
    end

  | gethints => fun betas hints etas =>
    match (with equality betas hints etas handle gethints) with
      | (?v, ?betas :: ?hints :: ?etas :: []) => yield v betas hints etas
    end

  | getetas => fun betas hints etas =>
    match (with equality betas hints etas handle getetas) with
      | (?v, ?betas :: ?hints :: ?etas :: []) => yield v betas hints etas
    end

  | val ?v => fun betas hints etas => v

  | finally ?f => f betas hints etas
  end

(* TODO split into lbeta|lhint|... functions *)
let local = fun action =>
  let betas = getbetas and hints = gethints and etas = getetas in
  match (with equality betas hints etas handle
    match action with
      | lbeta ?b => beta b
      | lhint ?h => hint h
      | leta  ?h => eta  h
    end) with
    | (_, ?betas :: ?hints :: ?etas :: []) =>
      equality_in betas hints etas
  end

let top_betas = ref []
let top_hints = ref []
let top_etas  = ref []

(* top level handler with no hints *)
handle
  | equal a b =>
    with equality_in !top_betas !top_hints !top_etas handle equal a b

  | whnf e =>
    with equality_in !top_betas !top_hints !top_etas handle whnf e

  | as_prod e =>
    match (with equality_in !top_betas !top_hints !top_etas handle whnf e) with
      | |- ?eq : _ == (forall (_ : _), _) => Some eq
      | _ => None
    end

  | as_eq e =>
    match (with equality_in !top_betas !top_hints !top_etas handle whnf e) with
      | |- ?eq : _ == (_ == _) => Some eq
      | _ => None
    end

  | as_signature e => (* TODO no good way to match generic signature *)
    let eq = 
      with equality_in !top_betas !top_hints !top_etas handle whnf e
    in
    Some eq

  | beta b =>
    match (with equality !top_betas !top_hints !top_etas handle beta b) with
      | (_, ?betas :: ?hints :: ?etas :: []) =>
        top_betas := betas
    end

  | hint h =>
    match (with equality !top_betas !top_hints !top_etas handle hint h) with
      | (_, ?betas :: ?hints :: ?etas :: []) =>
        top_hints := hints
    end

  | eta h =>
    match (with equality !top_betas !top_hints !top_etas handle eta h) with
      | (_, ?betas :: ?hints :: ?etas :: []) =>
        top_etas := etas
    end

  | getbetas =>
    !top_betas

  | gethints =>
    !top_hints

  | getetas =>
    !top_etas
end

(* helper functions *)
let add_beta = fun b =>
  match with equality !top_betas !top_hints !top_etas handle beta b with
    | (_, ?betas :: _ :: _ :: []) => top_betas := betas
  end

let add_hint = fun h =>
  match with equality !top_betas !top_hints !top_etas handle hint h with
    | (_, _ :: ?hints :: _ :: []) => top_hints := hints
  end

let add_eta = fun h =>
  match with equality !top_betas !top_hints !top_etas handle eta h with
    | (_, _ :: _ :: ?etas :: []) => top_etas := etas
  end

