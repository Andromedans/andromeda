
#include_once "base.m31"
#include "utils.m31"

data (!!) 1 
let debug = fun x => print !! x

operation fail 0
operation beta 1
operation hint 1
operation whnf 1

(* local hints *)
data lbeta 1
data lhint 1
operation getbetas 0
operation gethints 0

(*
Matching works the following way:
we have a list (|- xs : As = maybe vs) of typed atoms with potential values, such that each atom may appear in the following types
we have a typed term (|- target : t) in which any of the atoms may appear
we have some value f
we have a typed term (|- e : te) which is being matched

we must find an instantiation of the xs such that t == te and target == e
such an instantiation is a list of vs
if we find it we return (Some (f vs))
otherwise we return None

Usually f is a term of type (forall xs : As, foo), but there's no reason it couldn't be a function or even something weird.

For instance a beta hint b : forall y : B, e1 ==[T] e2 gives us
- xs : As = [y : B]
- target : t = e1 : T
- f = b
matching with e : T gives us a witness of e == e2[??/y]
*)

(* assoc_update which fails to match if the value to update isn't already present *)
let assoc_update = fun x v lst =>
  let rec aux acc lst = match lst with
    | pair x _ :: ?lst => rev_append acc (pair x v :: lst)
    | ?y :: ?lst => aux (y :: acc) lst
    end
  in aux [] lst

(* updates quants with values such that lhs matches rhs *)
let rec collector quants lhs rhs =
  (* is lhs an atom?
     NB it would be nice to have a matching primitive to know if some term is an atom. *)
  match assoc_find lhs quants with
    | Some None => (* not yet set atom *)
      let quants = assoc_update lhs (Some rhs) quants in
      Some quants
    | Some (Some ?lhs) => (* already set atom *)
      collector quants lhs rhs
    | None => (* not an atom *)
      match assoc_find rhs quants with
        | Some None =>
          let quants = assoc_update rhs (Some lhs) quants in
          Some quants
        | Some (Some ?rhs) =>
          collector quants lhs rhs
        | None =>
          match pair lhs rhs with
            | pair ?a ?a => (* alpha equal *)
              Some quants
            | pair (|- ?l1 ?l2) (|- ?r1 ?r2) =>
              match collector quants l1 r1 with
                (* could there be something smarter to do in either failure case? *)
                | Some ?quants => collector quants l2 r2
                | None => None
              end
            | pair (|- ?l1 == ?l2) (|- ?r1 == ?r2) =>
              match collector quants l1 r1 with
                | Some ?quants => collector quants l2 r2
                | None => None
              end
            (* TODO add cases *)
            | _ => None
          end
      end
  end

let rec apply_quants f quants = match quants with
  | [] => Some f
  | pair _ None :: _ => None
  | pair _ (Some ?v) :: ?quants =>
    apply_quants (f v) quants
  end

let generic_matcher = fun pat e =>
  match pat with
    | pair ?f (pair ?quants ?lhs) =>
      match collector quants lhs e with
        | Some ?quants =>
          apply_quants f quants
        | None => None
      end
  end


let process_beta =
  let rec deep quants e b = match b with
    | |- forall (?x : _), ?b =>
      deep (pair x None :: quants) e b
    | |- ?lhs == _ => pair e (pair (rev quants) lhs)
    end
  in
  fun b => match b with
    | |- ?e : ?b => deep [] e b
    end

let process_hint =
  let rec deep quants e h = match h with
    | |- forall (?x : _), ?h =>
      deep (pair x None :: quants) e h
    | |- _ == _ => pair e (pair (rev quants) h)
    end
  in
  fun h => match h with
    | |- ?e : ?h => deep [] e h
    end

let sym = λ (A : Type, x y : A, h : x ≡ y), handle refl x : y ≡ x with
  | equal _ _ =>
    yield (Some h)
  end

let tran = lambda (t : Type) (a b c : t) (eq1 : a == b) (eq2 : b == c),
  handle eq2 : a == c with
    | equal ((|- a == c : _) as ?x) ((|- b == c : _) as ?y) => handle yield (congruence x y) with
      | equal a b => yield (Some eq1)
    end
  end

(* pick the rhs because it's more reduced in practice *)
let hide_witness = fun eq => match eq with
  |- _ : ?a == ?b => match a with |- _ : ?t =>
    handle refl b : a == b with equal b a => yield (Some (sym t a b eq)) end
  end end

(* implicit arguments and hide witness *)
let symmetry = fun eq =>
  match eq with
    |- _ : ?a == ?b =>
      match a with |- _ : ?t =>
        hide_witness (sym t a b eq)
      end
  end

let transitivity = fun eq1 eq2 =>
  match pair eq1 eq2 with
    | pair (|- _ : ?a == ?b) (|- _ : _ == ?c) =>
      match a with |- _ : ?t =>
        hide_witness (tran t a b c eq1 eq2)
      end
  end

let unopt = fun v => match v with
  | Some ?v => v
  end

(* attempt to apply one of betas to e (not to a subterm of e) *)
let rec step_at betas e =
  match betas with
    | [] => None
    | ?b :: ?rem =>
      match generic_matcher b e with
        | (Some _) as ?m => m
        | None => step_at rem e
      end
  end

let rec hint_at hints e =
  match hints with
    | [] => None
    | ?h :: ?rem =>
      match generic_matcher h e with
        | (Some _) as ?m => m
        | None => hint_at rem e
      end
  end

let rec do_whnf betas e =
  match e with
    | |- ?e1 ?e2 : ?t =>
      match do_whnf betas e1 with
        | Some (|- ?eq : _ == ?e1') =>
          (*
            At this point, [e2] has type [a] for some [a], and both [e1] and [e1'] have the same type [forall x : a, foo] such that [foo[e2/x] == t].
            However if that equality is difficult to derive the following ascription may do something undesired or fail.
            Therefore in the future it may be better to explicitly do
            match equal foo[e2/x] t with
              | Some ?eqt => use eqt in (e1' e2) : t
              | None => fail
            end
            
            The other option would be to have unicity of typing primitives which,
            given a judgement (ctx |- e : t) derives a type t' from the annotations of e and from ctx such that (ctx |- e : t'),
            and then return ctx |- refl t : t == t' and ctx |- e : t'
            
            then t' would be foo[e2/x] for both (e1 e2) and (e1' e2), problem solved (because e1, e1' : forall x : A, foo)
          *)
          let e' = e1' e2 in
          let e' = e' : t in
          let meq = handle congruence e e' with
            | equal e1 e1' => yield (Some eq)
            end
          in
          let eq = match meq with
              | Some ?eq => eq : e == e'
            end
          in
          match do_whnf betas e' with
            | Some (|- ?eq' : _ == ?e'') =>
              Some (transitivity eq eq')
            | None => Some eq
          end
        | None =>
          match reduce e with
            | Some (|- ?eq : _ == ?e') =>
              match do_whnf betas e' with
                | Some (|- ?eq' : _ == ?e'') =>
                  Some (transitivity eq eq')
                | None => Some eq
              end
            | None =>
              (* e1 is in whnf and e is not a beta redex, so we only need to see if a beta hint applies to e *)
              match step_at betas e with
                | Some (|- ?eq : _ == ?e') =>
                      match do_whnf betas e' with
                    | Some (|- ?eq' : _ == ?e'') =>
                      let eq = transitivity eq eq' in
                      Some eq
                    | None =>
                      Some eq
                  end
                | None => None
              end
          end
      end
    | |- _ : ?t =>
      match step_at betas e with
        | Some (|- ?eq : _ == ?e') =>
          match do_whnf betas e' with
            | Some (|- ?eq' : _ == ?e'') =>
              Some (transitivity eq eq')
            | None => Some eq
          end
        | None =>
          None
          (* TODO are there any non application cases where we need to reduce a subterm? *)
      end
  end

let whnf_eq = fun betas e =>
match do_whnf betas e with
  | Some ?eq => eq
  | None => refl e
  end

(* we return the betas and hints so that we may reuse them. eg
let comp1 = with equality betas hints handle (foo ... add_beta b ... baz)
let v = match comp1 with pair ?v _ => v end
let betas = match comp1 with pair _ (pair ?betas _) => betas
let hints = ...

let comp2 = with equality betas hints handle ...
...

then in comp2 the hint b is available
*)
let rec equality betas hints = handler
  | equal (|- ?a : ?t) ?b (* : ?t *) => fun betas hints =>
    match (with equality betas hints handle pair (whnf_eq betas a) (whnf_eq betas b)) with
    | pair (pair (|- ?eqa : _ == ?x) (|- ?eqb : _ == ?x)) (pair ?betas ?hints) =>
      (* whnfs are alpha equal *)
      let eq = transitivity eqa (symmetry eqb) in
      yield (Some eq) betas hints
    | pair (pair (|- ?eqa : _ == ?a') (|- ?eqb : _ == ?b')) (pair ?betas ?hints) =>
     match (with equality betas hints handle congruence a' b') with
        | pair (Some ?eq) (pair ?betas ?hints) =>
          let eq = transitivity eqa eq in
          let eq = transitivity eq (symmetry eqb) in
          yield (Some eq) betas hints
        | pair None _ =>
          match (with equality betas hints handle hint_at hints (a == b)) with
            | pair (Some ?eq) (pair ?betas ?hints) =>
              yield (Some eq) betas hints
            | pair None _ =>
              yield None betas hints
          end
      end
    end

  | whnf ?e => fun betas hints =>
    match (with equality betas hints handle whnf_eq betas e) with
      | pair ?eq (pair ?betas ?hints) =>
        yield eq betas hints
    end

  | beta ?b => fun betas hints =>
    let b = process_beta b in
    yield () (b :: betas) hints

  | hint ?h => fun betas hints =>
    let h = process_hint h in
    yield () betas (h :: hints)

  | getbetas => fun betas hints =>
    yield betas betas hints

  | gethints => fun betas hints =>
    yield hints betas hints

(* TODO | as_* *)

  | val ?v => fun betas hints => pair v (pair betas hints)

  | finally ?f => f betas hints
  end



(* doesn't return the state *)
let equality_in = fun betas hints => handler
  | equal (|- ?a : ?t) ?b (* : ?t *) => fun betas hints =>
    match (with equality betas hints handle equal a b) with
      | pair ?v (pair ?betas ?hints) => yield v betas hints
    end

  | whnf ?e => fun betas hints =>
    match (with equality betas hints handle whnf_eq betas e) with
      | pair ?v (pair ?betas ?hints) => yield v betas hints
    end

  | beta ?b => fun betas hints =>
    match (with equality betas hints handle beta b) with
      | pair ?v (pair ?betas ?hints) => yield v betas hints
    end

  | hint ?h => fun betas hints =>
    match (with equality betas hints handle hint h) with
      | pair ?v (pair ?betas ?hints) => yield v betas hints
    end

  | getbetas => fun betas hints =>
    match (with equality betas hints handle getbetas) with
      | pair ?v (pair ?betas ?hints) => yield v betas hints
    end

  | gethints => fun betas hints =>
    match (with equality betas hints handle gethints) with
      | pair ?v (pair ?betas ?hints) => yield v betas hints
    end

  | val ?v => fun betas hints => v

  | finally ?f => f betas hints
  end

(* TODO split into lbeta|lhint|... functions *)
let local = fun action =>
  let betas = getbetas and hints = gethints in
  match (with equality betas hints handle
    match action with
      | lbeta ?b => beta b
      | lhint ?h => hint h
    end) with
    | pair _ (pair ?betas ?hints) =>
      equality_in betas hints
  end

let top_betas = ref []
let top_hints = ref []

(* top level handler with no hints *)
handle
  | equal a b =>
    with equality_in !top_betas !top_hints handle equal a b

  | whnf e =>
    with equality_in !top_betas !top_hints handle whnf e

  | as_prod e =>
    match (with equality_in !top_betas !top_hints handle whnf e) with
      | |- ?eq : _ == (forall (_ : _), _) => Some eq
      | _ => None
    end

  | as_eq e =>
    match (with equality_in !top_betas !top_hints handle whnf e) with
      | |- ?eq : _ == (_ == _) => Some eq
      | _ => None
    end

  | as_signature e => (* TODO no good way to match generic signature *)
    with equality_in !top_betas !top_hints handle whnf e

  | beta b =>
    match (with equality !top_betas !top_hints handle beta b) with
      | pair _ (pair ?betas ?hints) =>
        top_betas := betas
    end

  | hint h =>
    match (with equality !top_betas !top_hints handle hint h) with
      | pair _ (pair ?betas ?hints) =>
        top_hints := hints
    end

  | getbetas =>
    !top_betas

  | gethints =>
    !top_hints
end

(* helper functions *)
let add_beta = fun b =>
  match with equality !top_betas !top_hints handle beta b with
    | pair _ (pair ?betas _) => top_betas := betas
  end

let add_hint = fun h =>
  match with equality !top_betas !top_hints handle hint h with
    | pair _ (pair ?hints) => top_hints := hints
  end

