#include_once "base.m31"
#include_once "utils.m31"

(* Operations for installing equality hints *)
operation beta 1  (* Install a beta hint *)
operation hint 1  (* Install a general hint *)
operation eta  1  (* Install an eta hint *)

(* Operations for installing local hints *)
data lbeta 1
data lhint 1
data leta  1

operation whnf 1  (* Compute the weak head normal form *)

(* These return a list of hints in a preprocessed form, see process_xyz *)
operation getbetas 0 (* Get the current beta hints *)
operation gethints 0 (* Get the current general hints *)
operation getetas  0 (* Get the current eta hints *)
operation getreducing 0
operation getstate 0

(* Used as
  `set_reducing plus [eager,eager]`
  `set_reducing fst [lazy,lazy,eager]`
*)
operation set_reducing 2
data eager 0
data lazy 0

(* One of the tasks we need to be able to do is this: given a universally quantified type
   `∏(x1:A1)...(xn:An) B` and a type `C`, find an instantiation `x1↦e1, ..., xn↦en` such that
   `B[x1↦e1, ..., xn↦en]` equals `C`. Of course, everything has to be well-typed etc.

   We provide here functions that solve this task, and in fact work more generally:
   given a term `b` and atoms `x1:A1, ..., xn:An`, find an instantiation of the atoms
   that will make b equal to a given term `c`.

   We build the instantiation in steps. A partial instantiation below is called `quants`.
   It has 2 components:
   - an associative list of pattern variables which maps an atom `x` to either `None` or `Some t`
     where `t` is the instantiation for `x`.
   - a list of forbidden ('rigid') variables which are introduced in equivalent pairs
     (when we descend in `forall x : A, B` and `forall y : A', B'`,
     we know that `A' == B'` but only under the instantiation, so we can't combine `x` and `y`.
     We also are not allowed to instantiate a pattern variable to any term that depends on `x` or `y`)

   TODO occurs check (currently we might instantiate `x := f y`, `y := g x`)
*)

let (>?=) m f = match m with
  | Some ?x => f x
  | None => None
  end

(* Get information about an atom.
   If it's a pattern variable,
   return `Some None` if it isn't instantiated
   and `Some (Some v)` if it is instantiated to `v`.
   If it's a rigid variable, return `None` if it is the second of the pair and `Some y` if `y` is the second of the pair. *)
let atom_find x quants =
  match quants with
  (?vars,?rigids) =>
    let u = assoc_find x vars in
    match u with
      | (Some _) as ?v => v
      | None => match assoc_find x rigids with
          | Some ?y => Some (Some y)
          | None => None
        end
    end
  end

(* Are we allowed to use `e` to instantiate some pattern variable? *)
let rec rigid_occurs e rigids = match rigids with
  | [] => None
  | (?x,?y)::?rigids =>
    match occurs x e with
      | (Some _) as ?v => v
      | None => match occurs y e with
          | (Some _) as ?v => v
          | None => rigid_occurs e rigids
        end
    end
  end

(* try to instantiate `x` with `e` *)
let atom_update x e quants =
  match quants with
  (?vars,?rigids) =>
    match rigid_occurs e rigids with
      | Some ?y =>
        None
      | None =>
        Some (assoc_update x (Some e) vars,rigids)
    end
  end

let add_paired_rigids x y quants = match quants with (?vars,?rigids) => (vars,(x,y)::rigids) end

(* After going under a binder, we can remove its hypothesis from the instantiation.
   Not doing so doesn't affect correctness but dirties the instantiation. *)
let pop_rigid quants =
  match quants with
    (?vars, _ :: ?rigids) => (vars,rigids)
  end

(* Signatures introduce multiple rigids in a row. Their number is represented by a stack of `Somes`. *)
let rec pop_rigids pop quants =
  match pop with
    | None => quants
    | Some ?pop =>
      let quants = pop_rigid quants in
      pop_rigids pop quants
  end

(* Return `(quants',x',y')` where `x'` is `x` fully instantiated by `quants'` (resp `y'`, `y`)
   and `quants'` is `quants` possibly updated to make `x'` and `y'` equal.
   Note that `x'` and `y'` are usually not equal. *)
let rec inst_sides quants x y =
  match x with
  |- _atom _ =>
    match atom_find x quants with
      | Some None => (* not yet set atom *)
        atom_update x y quants >?= (fun quants =>
        Some (quants,y,y))
      | Some (Some ?x') => (* already set atom *)
        inst_sides quants x' y
      | None => (* not a pattern variable *)
        match y with
        |- _atom _ =>
          match atom_find y quants with
            | Some None =>
              atom_update y x quants >?= (fun quants =>
              Some (quants,x,x))
            | Some (Some ?y') =>
              inst_sides quants x y'
            | None =>
              Some (quants,x,y)
          end
        | _ => Some (quants,x,y)
        end
    end
  | _ =>
    match y with
    |- _atom _ =>
      match atom_find y quants with
        | Some None =>
          atom_update y x quants >?= (fun quants =>
          Some (quants,x,x))
        | Some (Some ?y') =>
          inst_sides quants x y'
        | None =>
          Some (quants,x,y)
      end
    | _ => Some (quants,x,y)
    end
  end

let rec collector_shares collector pop quants s1 s2 = match (s1, s2) with
    | ([], []) => Some (pop_rigids pop quants)
    | ((Unconstrained ?a)::?s1, (Unconstrained ?b)::?s2) => (* non constrained *)
      let quants = add_paired_rigids a b quants in
      collector_shares collector (Some pop) quants s1 s2
    | ((Constrained ?a)::?s1, (Constrained ?b)::?s2) => (* constrained *)
      collector quants a b >?= (fun quants =>
      collector_shares collector pop quants s1 s2)
    | ((Unconstrained _)::_, (Constrained _)::_) => None
    | ((Constrained _)::_, (Unconstrained _)::_) => None
  end

let rec collector_struct collector quants l1 l2 = match (l1,l2) with
  | ([], []) => Some quants
  | (?e1 :: ?l1, ?e2 :: ?l2) =>
    collector quants e1 e2 >?= (fun quants =>
    collector_struct collector quants l1 l2)
  end


(* Update `quants` with values such that `lhs` matches `rhs`.
   Return updated `Some quants`, or `None` if `lhs` could not
   be made to match `rhs`.

   If `Some quants` is returned then `lhs` instantiated with
   `quants` will be equal to `rhs` instantiated with `quants`.
*)
let rec collector quants lhs rhs =
    match inst_sides quants lhs rhs with
      | Some (?quants,?lhs,?rhs) =>
        match (lhs, rhs) with
          | (?a, ?a) => (* alpha equal *)
            Some quants

          | ((|- lambda (?x1 : ?a1), ?e1), (|- lambda (?x2 : ?a2), ?e2)) =>
            match (e1, e2) with
              ((|- _ : ?b1), (|- _ : ?b2)) =>
                collector quants a1 a2 >?= (fun quants =>
                let quants = add_paired_rigids x1 x2 quants in
                collector quants b1 b2 >?= (fun quants =>
                collector quants e1 e2 >?= (fun quants =>
                let quants = pop_rigid quants in
                Some quants)))
            end

          | ((|- ?l1 ?r1), (|- ?l2 ?r2)) =>
            (* extract annotations *)
            match (l1, l2) with
              ((|- _ : forall (?x1 : ?a1), ?b1), (|- _ : forall (?x2 : ?a2), ?b2)) =>
                collector quants a1 a2 >?= (fun quants =>
                let quants = add_paired_rigids x1 x2 quants in
                collector quants b1 b2 >?= (fun quants =>
                collector quants l1 l2 >?= (fun quants =>
                let quants = pop_rigid quants in
                collector quants r1 r2)))
            end

          | ((|- forall (?x1 : ?a1), ?b1), (|- forall (?x2 : ?a2), ?b2)) =>
            collector quants a1 a2 >?= (fun quants =>
            let quants = add_paired_rigids x1 x2 quants in
            collector quants b1 b2 >?= (fun quants =>
            let quants = pop_rigid quants in
            Some quants))

          | ((|- ?l1 == ?r1), (|- ?l2 == ?r2)) =>
            match (l1, l2) with
              ((|- _ : ?t1), (|- _ : ?t2)) =>
                collector quants t1 t2 >?= (fun quants =>
                collector quants l1 l2 >?= (fun quants =>
                collector quants r1 r2))
            end

          | ((|- refl ?e1), (|- refl ?e2)) =>
            match (e1, e2) with
              ((|- _ : ?t1), (|- _ : ?t2)) =>
                collector quants t1 t2 >?= (fun quants =>
                collector quants e1 e2)
            end

          | (|- _proj ?e1 ?l, |- _proj ?e2 ?l) =>
            match (e1, e2) with
              ((|- _ : ?t1), (|- _ : ?t2)) =>
                collector quants t1 t2 >?= (fun quants =>
                collector quants e1 e2)
            end

          | (|- _sig ((?s,_),?shares1), |- _sig ((?s,_),?shares2)) =>
            (* NB: we don't care about the signature definition.
               NB': the signature names have to be equal *)
            collector_shares collector None quants shares1 shares2

          | (|- _struct ?s1 ?l1, |- _struct ?s2 ?l2) =>
            collector quants s1 s2 >?= (fun quants =>
            collector_struct collector quants l1 l2)

          | _ => None
        end
      | None => None
    end


(* Given `(x1, Some v1), ..., (xn, Some vn)` apply `f` to the
   values `v1, ..., vn` and return `Some (f v1 ... vn)`.
   If any of the `Some vi` is `None`, fail by returning `None`.
*)
let rec apply_quants f quants = match quants with
  | [] => Some f
  | (_, None) :: _ => None
  | (_, Some ?v) :: ?quants =>
    apply_quants (f v) quants
  end

(* given `pat = (f,quants,lhs)`
   where `quants` is an instantiation (usually with only non instantiated pattern variables),
   match `e` with `lhs` and apply `f` to the resulting instantiation if successful.

   `f` may be either a closure or a term with a product type.
*)
let generic_matcher pat e =
  match pat with
    | (?f, (?quants, ?lhs)) =>
      match collector (quants,[]) lhs e with
        | Some (?quants,_) =>
          apply_quants f quants
        | None => None
      end
  end

(* A beta hint is a term `e` whose type is a universally quantified equation
   `∏ (x1:A1) ... (xn:An), lhs == rhs`.
   It is used by matching `lhs` against a term to be reduced to the instantiated `rhs`.

   If the instantiation of `x1, .., xn` cannot be read off `lhs` (because not all the
   `x1, ..., xn` appear in it) then the beta hint will fail later on (at the `apply_quants` stage).
*)
let process_beta =
  let rec deep quants e b = match b with
    | |- forall (?x : _), ?b =>
      deep ((x, None) :: quants) e b
    | |- ?lhs == _ => (e, (rev quants, lhs))
    end
  in
  fun e => match e with
    | |- ?e : ?b => deep [] e b
    end

(* A general hint is a term `e` of type `forall [xs], lhs == rhs`.
  It is used by matching `lhs == rhs` against an equality type to be verified. *)
let process_hint =
  let rec deep quants e h = match h with
    | |- forall (?x : _), ?h =>
      deep ((x, None) :: quants) e h
    | |- _ == _ => (e, (rev quants, h))
    end
  in
  fun h => match h with
    | |- ?e : ?h => deep [] e h
    end

(* An eta hint is a term `e` of type `forall [xs] [a b : T] [eqs : ?? == ??], a == b`. It
  is used by matching `T` with the type of a target equality, then filling in `a` and `b`
  and solving the `eqs`.

  If we have an equation `lhs == rhs` at type `T'` to solve through eta:
  * match `T` with `T'` to instantiate `xs` to `vs`
  * compute `e vs lhs rhs` to get a term of type `forall [eqs], lhs == rhs`
  * solve the `eqs`

  TODO allow `eqs : forall [ys] ?? == ??`
  This is necessary eg for `funext` (which has `eq : forall x, f x == g x`)
*)
let process_eta =
  (* we have matched t with the general shape of an eta hint *)
  let finalize e xs eqs a b =
    let T = match a with |- _ : ?T => T end in
    let rec f e xs = match xs with
      | [] =>
        fun ea eb =>
        let e = e ea eb in
        (* now we have e : forall [eqs[ea,eb]], ea == eb and we need to solve the eqs *)
        let rec auto e = match e with
          | |- _ : forall (_ : ?lhs == ?rhs), _ =>
            match equal lhs rhs with
              | Some ?eq => auto (e eq)
              | None => None
            end
          | |- _ : _ == _ => Some e
          end
        in
        auto e
      | _ :: ?xs =>
        fun v => f (e v) xs
      end
    in
    (f e xs, (xs, T))
  in
  (* quants++(rev eqs) is the list [xs;a;b;eqs] in reverse order. We want to split it into [xs] and [eqs]. *)
  let rec quant_splitter e eqs quants a b =
    match quants with
      | (b, _) :: (a, _) :: ?xs =>
        let xs = rev xs in
        finalize e xs eqs a b
      | ?eq :: ?quants =>
        quant_splitter e (eq::eqs) quants a b
      | [] => let _ = print "Bad eta:" in let _ = print e in match [] with end
    end
  in
  let rec deep quants e h = match h with
    | |- forall (?x : _), ?h =>
      deep ((x, None) :: quants) e h
    | |- ?a == ?b =>
      quant_splitter e [] quants a b
    end
  in
  fun h => match h with
    | |- ?e : ?t => deep [] e t
    end

let process_reducing c l =
  let _ = match c with
      | |- _constant _ => ()
      | |- _atom _ => ()
      | |- _proj _ _ => ()
      | _ => failure "only constants and atoms may have reducing information"
    end in
  (c,l)

(* The term witnessing symmetry of equality. *)
let sym = λ (A : Type) (x y : A) (h : x ≡ y), handle refl x : y ≡ x with
  | equal _ _ =>
    yield (Some h)
  end

(* The term witnessing transitivity of equality *)
let tran = lambda (t : Type) (a b c : t) (eq1 : a == b) (eq2 : b == c),
  handle eq2 : a == c with
    | equal ((|- a == c : _) as ?x) ((|- b == c : _) as ?y) => handle yield (congruence x y) with
      | equal a b => yield (Some eq1)
    end
  end

(* Take `p : a == b` and return `refl b : a == b`. This is used to make
   witnesses of equalities small. *)
let hide_witness eq = match eq with
  |- _ : ?a == ?b => match a with |- _ : ?t =>
    handle refl b : a == b with equal b a => yield (Some (sym t a b eq)) end
  end end

(* Take `p : a == b` and return `refl a : b == a`. This is used instead
   of `sym` to keep witnesses of equality small. *)
let symmetry eq =
  match eq with
    |- _ : ?a == ?b =>
      match a with |- _ : ?t =>
        hide_witness (sym t a b eq)
      end
  end

(* As `symmetry` but for transitivity. *)
let transitivity eq1 eq2 =
  match (eq1, eq2) with
    | ((|- _ : ?a == ?b), (|- _ : ?b == ?c)) =>
      match a with |- _ : ?t =>
        hide_witness (tran t a b c eq1 eq2)
      end
  end

(* Attempt to apply one of `betas` to a term `e`. Here `betas` is a list of beta hints previously
   processed by `process_beta`. Return `Some (⊢ p : e == e')` or `None` if no hint applies. *)
let rec step_at betas e =
  match betas with
    | [] => None
    | ?b :: ?rem =>
      match generic_matcher b e with
        | (Some _) as ?m => m
        | None => step_at rem e
      end
  end

(* Attempt to apply one of general `hints` to an equation `e`. Return `Some (⊢ p : e)` or
   `None` if no hint applies. *)
let rec hint_at hints e =
  match hints with
    | [] => None
    | ?h :: ?rem =>
      match generic_matcher h e with
        | (Some _) as ?m => m
        | None => hint_at rem e
      end
  end

(* Attempt to apply one of `etas` to equation `a == b` at type `t`. It will trigger further
   operations that try to solve the resulting subproblems. Return `Some (⊢ p : a == b)` on
   success, or `None` otherwise. *)
let rec eta_at etas a b t =
  match extensionality a b with
    | Some ?eq => Some eq
    | None =>
      match etas with
        | [] => None
        | ?h :: ?rem =>
          match generic_matcher h t with
            | Some ?f => f a b
            | None => eta_at rem a b t
          end
      end
  end

let compute_reducing reducing e =
  match assoc_find e reducing with
    | Some ?v => v
    | None => []
  end

let opt_transitivity meq eq' = match meq with
  | Some ?eq => transitivity eq eq'
  | None => eq'
end

(* Compute the weak head normal form of a term `e` using the `betas` hints.
   Return `(eq,r)` where
   `eq` is `Some (⊢ p : e == e')` where `e'` is the normal form,
        or `None` if `e` is already normal.
   `r` is information about how to reduce arguments when `e` is applied *)
let rec do_whnf betas reducing e =
  match e with
    | |- ?e1 ?e2 : ?t =>
      match do_whnf betas reducing e1 with
        | (Some (|- ?eq : _ == ?e1'), ?rlst) =>
          (*
            At this point, [e2] has type [a] for some [a], and both [e1] and [e1'] have the same type [forall x : a, foo] such that [foo[e2/x] == t].
            However if that equality is difficult to derive the following ascription may do something undesired or fail.
            Therefore in the future it may be better to explicitly do
            match equal foo[e2/x] t with
              | Some ?eqt => use eqt in (e1' e2) : t
              | None => fail
            end

            The other option would be to have unicity of typing primitives which,
            given a judgement (ctx |- e : t) derives a type t' from the annotations of e and from ctx such that (ctx |- e : t'),
            and then return ctx |- refl t : t == t' and ctx |- e : t'

            then t' would be foo[e2/x] for both (e1 e2) and (e1' e2), problem solved (because e1, e1' : forall x : A, foo)
          *)
          let e' = e1' e2 in
          let e' = e' : t in
          let meq = handle congruence e e' with
            | equal e1 e1' => yield (Some eq)
            end
          in
          let eq = match meq with
              | Some ?eq => eq : e == e'
            end
          in
          match do_whnf betas reducing e' with
            | (Some (|- ?eq' : _ == ?e''), ?rlst) =>
              let eq = transitivity eq eq' in
              (Some eq, rlst)
            | (None,?rlst) =>
              (Some eq, rlst)
          end
        | (None,?rlst) =>
          match reduction e with
            | Some (|- ?eq : _ == ?e') =>
              match do_whnf betas reducing e' with
                | (Some (|- ?eq' : _ == ?e''), ?rlst) =>
                  let eq = transitivity eq eq' in
                  (Some eq, rlst)
                | (None,?rlst) => (Some eq,rlst)
              end
            | None =>
              (* `e1` is in whnf and `e1 e2` not a beta redex *)
              (* Do we need to reduce `e2`? *)
              let meq = match rlst with
                | [] => None
                | ?b::_ =>
                  match b with
                    | eager =>
                      match do_whnf betas reducing e2 with
                        | (Some (|- ?eq2 : _ == ?e2'),_) =>
                          let e' = e1 e2' in
                          let e' = e' : t in (* <- this should use eq2 *)
                          handle congruence e e' with
                            | equal e2 e2' => yield (Some eq2)
                          end
                        | (None,_) => None
                      end
                    | lazy =>
                      None
                  end
              end in
              let e' = match meq with Some (|- _ : _ == ?e') => e' | None => e end in
              (* e1 is in whnf and e is not a beta redex, so we only need to see if a beta hint applies to e *)
              match step_at betas e' with
                | Some (|- ?eq' : _ == ?e'') =>
                  let eq = opt_transitivity meq eq' in
                  match do_whnf betas reducing e'' with
                    | (Some (|- ?eq'' : _ == _),?rlst) =>
                      let eq = transitivity eq eq'' in
                      (Some eq,rlst)
                    | (None,?rlst) =>
                      (Some eq, rlst)
                  end
                | None =>
                  let rlst = match rlst with [] => [] | _::?rlst => rlst end in
                  (meq,rlst)
              end
          end
      end
    | |- _proj ?e0 ?l : ?t =>
      match do_whnf betas reducing e0 with
        | (Some (|- ?eq : _ == ?e0'),_) =>
          let e' = _proj e0' l in
          let e' = e' : t in
          let meq = handle congruence e e' with
            | equal e0 e0' => yield (Some eq)
            end
          in
          let eq = match meq with
              | Some ?eq => eq : e == e'
            end
          in
          match do_whnf betas reducing e' with
            | (Some (|- ?eq' : _ == ?e''),?rlst) =>
              let eq = transitivity eq eq' in
              (Some eq,rlst)
            | (None,?rlst) => (Some eq,rlst)
          end
        | (None,_) =>
          match reduction e with
            | Some (|- ?eq : _ == ?e') =>
              match do_whnf betas reducing e' with
                | (Some (|- ?eq' : _ == ?e''),?rlst) =>
                  let eq = transitivity eq eq' in
                  (Some eq,rlst)
                | (None,?rlst) => (Some eq,rlst)
              end
            | None =>
              (* e0 is in whnf and e is not a beta redex, so we only need to see if a beta hint applies to e *)
              match step_at betas e with
                | Some (|- ?eq : _ == ?e') =>
                  match do_whnf betas reducing e' with
                    | (Some (|- ?eq' : _ == ?e''),?rlst) =>
                      let eq = transitivity eq eq' in
                      (Some eq, rlst)
                    | (None, ?rlst) =>
                      (Some eq, rlst)
                  end
                | None =>
                  let rlst = compute_reducing reducing e in
                  (None, rlst)
              end
          end
      end
    | |- _ : ?t =>
      match step_at betas e with
        | Some (|- ?eq : _ == ?e') =>
          match do_whnf betas reducing e' with
            | (Some (|- ?eq' : _ == ?e''),?rlst) =>
              let eq = transitivity eq eq' in
              (Some eq,rlst)
            | (None,?rlst) => (Some eq,rlst)
          end
        | None =>
          let rlst = compute_reducing reducing e in
          (None,rlst)
      end
  end

let reducing_spine reducing e =
  let rec fold e = match e with
    | |- ?e1 _ => match fold e1 with [] => [] | _::?l => l end
    | _ => compute_reducing reducing e
  end in
  fold e


(* Like `do_whnf betas e` except that it always returns the witness of equality between
   `e` and its normal form (so reflexivity if `e` is normal). *)
let whnf_eq betas reducing e =
  match do_whnf betas reducing e with
    | (Some ?eq,_) => eq
    | (None,_) => refl e
  end

(* Structurally compare the whnf of `a` and `b`. Return `Some (⊢ p : a == b)` on
   success, otherwise `None`. It will trigger general equality problems on subterms. *)
let rec equate_congr a b =
  let betas = getbetas and reducing = getreducing in
  match (whnf_eq betas reducing a, whnf_eq betas reducing b) with
    ((|- ?eqa : _ == ?a'), (|- ?eqb : _ == ?b')) =>
      let r = match (a',b') with
        | (|- ?a1 ?a2, |- ?b1 ?b2) =>
          (* We need to compare the head structurally because of lambda extensionality *)
          handle congruence a' b' with
            | equal a1 b1 => yield (equate_congr a1 b1)
            | equal (a2 as ?x) (b2 as ?y) =>
              let red = match reducing_spine reducing a1 with [] => lazy | ?b :: _ => b end in
              match red with
                | eager =>
                  yield (equate_congr x y)
                | lazy =>
                  yield (equal x y)
              end
          end
        | (|- _proj ?a0 _, |- _proj ?b0 _) =>
          handle congruence a' b' with | equal a0 b0 => yield (equate_congr a0 b0) end
        | _ =>
          congruence a' b'
      end in
      match r with
        | Some ?eq =>
          let eq = transitivity eqa (transitivity eq (symmetry eqb)) in
          Some eq
        | None => None
      end
  end

(* if `x : A` and `eq : A == B` return `x : B` *)
let convert x eq = match eq with
(*  | |- _ : ?t == ?t => x*)
  | |- _ : _ == ?t =>
    handle x : t with equal _ _ => yield (Some (symmetry eq)) end
  end

(* if `eq = (a == b : A)` and `eqt : A == B` return a witness of `(a == b : A) == (a == b : B)` *)
let convert_eq eq eqt = match (eq,eqt) with
  | (_, |- _ : ?t == ?t) => refl eq
  | (|- ?a == ?b, |- _ : _ == ?t) =>
    let a' = convert a eqt and b' = convert b eqt in
    let eq' = a' == b' in
    match handle congruence eq eq' with equal _ _ => yield (Some eqt) end with
    Some ?eq => eq
    end
end

(* Try to show that [x] and [y] are equal by applying in succession:
   general hints, eta hints, and structural equality. *)
let rec equate x y =
  (* x and y must have the same derived type *)
  let t = match (x, y) with ((|- _ : ?t), (|- _ : ?t)) => t end in
  match (handle whnf_eq getbetas getreducing t with equal ?a ?b => yield (equate a b) end) with
  |- ?eqt : _ == ?t' =>
    let x = convert x eqt and y = convert y eqt in
    let r = match hint_at gethints (x == y) with
      | None =>
        match (handle eta_at getetas x y t with equal ?a ?b => yield (equate a b) end) with
          | Some ?eq => Some eq
          | None =>
            handle equate_congr x y with equal ?a ?b => yield (equate a b) end
        end
      | Some ?eq =>
        Some eq
    end
    in match r with
      | Some (|- ?eq : ?teq) =>
        Some (convert eq (convert_eq teq eqt))
      | None => None
    end
  end

let state_betas state = match state with
  | (?betas,_,_,_) => betas
end

let state_add_beta state b = match state with
  | (?betas,?hints,?etas,?reducing) =>
    let betas = b::betas in
    (betas,hints,etas,reducing)
end

let state_hints state = match state with
  | (_,?hints,_,_) => hints
end

let state_add_hint state h = match state with
  | (?betas,?hints,?etas,?reducing) =>
    let hints = h::hints in
    (betas,hints,etas,reducing)
end

let state_etas state = match state with
  | (_,_,?etas,_) => etas
end

let state_add_eta state e = match state with
  | (?betas,?hints,?etas,?reducing) =>
    let etas = e::etas in
    (betas,hints,etas,reducing)
end

let state_reducing state = match state with
  | (_,_,_,?reducing) => reducing
end

let state_add_reducing state r = match state with
  | (?betas,?hints,?etas,?reducing) =>
    let reducing = r::reducing in
    (betas,hints,etas,reducing)
end

let hint_provider state = handler
  | getbetas => yield (state_betas state)
  | gethints => yield (state_hints state)
  | getetas => yield (state_etas state)
  | getreducing => yield (state_reducing state)
  | getstate => yield state
  end

(* we return the betas and hints so that we may reuse them. eg
let comp1 = with equality betas hints handle (foo ... add_beta b ... baz)
let v = match comp1 with (?v, _) => v end
let betas = match comp1 with (_, (?betas, _)) => betas
let hints = ...

let comp2 = with equality betas hints handle ...
...

then in comp2 the hint b is available
*)
let rec equality state = handler
  | equal (|- ?a : ?t) ?b (* : ?t *) => fun state =>
    let r = (with hint_provider state handle equate a b) in
    yield r state

  | whnf ?e => fun state =>
    let eq = (with equality state handle whnf_eq getbetas getreducing e) in
    yield eq state

  | as_prod ?e => fun state =>
    match (with equality state handle whnf_eq getbetas getreducing e) with
      | |- ?eq : _ == (forall (_), _) =>
        yield (Some eq) state
      | _ => yield None state
    end

  | as_eq ?e => fun state =>
    match (with equality state handle whnf_eq getbetas getreducing e) with
      | |- ?eq : _ == (_ == _) =>
        yield (Some eq) state
      | _ => yield None state
    end

  | as_signature ?e => fun state =>
    match (with equality state handle whnf_eq getbetas getreducing e) with
      | |- ?eq : _ == (_sig _) =>
        yield (Some eq) state
      | _ => yield None state
    end

  | beta ?b => fun state =>
    let b = process_beta b in
    let state = state_add_beta state b in
    yield () state

  | hint ?h => fun state =>
    let h = process_hint h in
    let state = state_add_hint state h in
    yield () state

  | eta ?h => fun state =>
    let h = process_eta h in
    let state = state_add_eta state h in
    yield () state

  | set_reducing ?c ?l => fun state =>
    let r = process_reducing c l in
    let state = state_add_reducing state r in
    yield () state

  | getbetas => fun state =>
    yield (state_betas state) state

  | gethints => fun state =>
    yield (state_hints state) state

  | getetas => fun state =>
    yield (state_etas state) state

  | getreducing => fun state =>
    yield (state_reducing state) state

  | getstate => fun state => yield state state

  | val ?v => fun state => v

  | finally ?f => f state
  end

(* TODO split into lbeta|lhint|... functions *)
let local action =
  let state = getstate in
  let state = match action with
    | lbeta ?b => state_add_beta state (process_beta b)
    | lhint ?h => state_add_hint state (process_hint h)
    | leta  ?h => state_add_eta  state (process_eta  h)
  end in
  equality state

(* state: betas,hints,etas,reducing *)
let empty_state = ([],[],[],[])
let top_state = ref empty_state

(* top level handler with no hints *)
handle
  | equal ?a ?b =>
    with equality !top_state handle equal a b

  | whnf ?e =>
    with equality !top_state handle whnf e

  | as_prod ?e =>
    with equality !top_state handle as_prod e

  | as_eq ?e =>
    with equality !top_state handle as_eq e

  | as_signature ?e =>
    with equality !top_state handle as_signature e

  | beta ?b =>
    let b = process_beta b in
    top_state := state_add_beta !top_state b

  | hint ?h =>
    let h = process_hint h in
    top_state := state_add_hint !top_state h

  | eta ?h =>
    let h = process_eta h in
    top_state := state_add_eta !top_state h

  | set_reducing ?c ?l =>
    let r = process_reducing c l in
    top_state := state_add_reducing !top_state r

  | getbetas =>
    state_betas !top_state

  | gethints =>
    state_hints !top_state

  | getetas =>
    state_etas !top_state

  | getreducing =>
    state_reducing !top_state

  | getstate => !top_state
end

(* helper functions *)
let add_beta b =
  let b = process_beta b in
  top_state := state_add_beta !top_state b

let add_hint h =
  let h = process_hint h in
  top_state := state_add_hint !top_state h

let add_eta h =
  let h = process_eta h in
  top_state := state_add_eta !top_state h

let add_betas bs = fold (fun _ b => add_beta b) () bs
let add_hints bs = fold (fun _ b => add_hint b) () bs
let add_etas  bs = fold (fun _ b => add_eta b) () bs

let fasteq _ = equality getstate

