(* The normalization hints. *)

dynamic betas = []

let (>?=) m f = match m with
  | Some ?x => f x
  | None => None
  end

(* Get information about an atom.
   If it's a pattern variable,
   return `Some None` if it isn't instantiated
   and `Some (Some v)` if it is instantiated to `v`.
   If it's a rigid variable, return `None` if it is the second of the pair and `Some y` if `y` is the second of the pair. *)
let atom_find x quants =
  match quants with
  (?vars,?rigids) =>
    let u = assoc_find x vars in
    match u with
      | (Some _) as ?v => v
      | None => match assoc_find x rigids with
          | Some ?y => Some (Some y)
          | None => None
        end
    end
  end

(* Are we allowed to use `e` to instantiate some pattern variable? *)
let rec rigid_occurs e rigids = match rigids with
  | [] => None
  | (?x,?y)::?rigids =>
    match occurs x e with
      | (Some _) as ?v => v
      | None => match occurs y e with
          | (Some _) as ?v => v
          | None => rigid_occurs e rigids
        end
    end
  end

(* try to instantiate `x` with `e` *)
let atom_update x e quants =
  match quants with
  (?vars,?rigids) =>
    match rigid_occurs e rigids with
      | Some ?y =>
        None
      | None =>
        Some (assoc_update x (Some e) vars,rigids)
    end
  end

let add_paired_rigids x y quants = match quants with (?vars,?rigids) => (vars,(x,y)::rigids) end

(* After going under a binder, we can remove its hypothesis from the instantiation.
   Not doing so doesn't affect correctness but dirties the instantiation. *)
let pop_rigid quants =
  match quants with
    (?vars, _ :: ?rigids) => (vars,rigids)
  end

(* Return `(quants',x',y')` where `x'` is `x` fully instantiated by `quants'` (resp `y'`, `y`)
   and `quants'` is `quants` possibly updated to make `x'` and `y'` equal.
   Note that `x'` and `y'` are usually not equal. *)
let rec inst_sides quants x y =
  match x with
  |- _atom _ =>
    match atom_find x quants with
      | Some None => (* not yet set atom *)
        atom_update x y quants >?= (fun quants =>
        Some (quants,y,y))
      | Some (Some ?x') => (* already set atom *)
        inst_sides quants x' y
      | None => (* not a pattern variable *)
        match y with
        |- _atom _ =>
          match atom_find y quants with
            | Some None =>
              atom_update y x quants >?= (fun quants =>
              Some (quants,x,x))
            | Some (Some ?y') =>
              inst_sides quants x y'
            | None =>
              Some (quants,x,y)
          end
        | _ => Some (quants,x,y)
        end
    end
  | _ =>
    match y with
    |- _atom _ =>
      match atom_find y quants with
        | Some None =>
          atom_update y x quants >?= (fun quants =>
          Some (quants,x,x))
        | Some (Some ?y') =>
          inst_sides quants x y'
        | None =>
          Some (quants,x,y)
      end
    | _ => Some (quants,x,y)
    end
  end

(* Update `quants` with values such that `lhs` matches `rhs`.
   Return updated `Some quants`, or `None` if `lhs` could not
   be made to match `rhs`.

   If `Some quants` is returned then `lhs` instantiated with
   `quants` will be equal to `rhs` instantiated with `quants`.
*)
let rec collector quants lhs rhs =
    match inst_sides quants lhs rhs with
      | Some (?quants,?lhs,?rhs) =>
        match (lhs, rhs) with
          | (?a, ?a) => (* alpha equal *)
            Some quants

          | ((|- lambda (?x1 : ?a1), ?e1), (|- lambda (?x2 : ?a2), ?e2)) =>
            match (e1, e2) with
              ((|- _ : ?b1), (|- _ : ?b2)) =>
                collector quants a1 a2 >?= (fun quants =>
                let quants = add_paired_rigids x1 x2 quants in
                collector quants b1 b2 >?= (fun quants =>
                collector quants e1 e2 >?= (fun quants =>
                let quants = pop_rigid quants in
                Some quants)))
            end

          | ((|- ?l1 ?r1), (|- ?l2 ?r2)) =>
            (* extract annotations *)
            match (l1, l2) with
              ((|- _ : forall (?x1 : ?a1), ?b1), (|- _ : forall (?x2 : ?a2), ?b2)) =>
                collector quants a1 a2 >?= (fun quants =>
                let quants = add_paired_rigids x1 x2 quants in
                collector quants b1 b2 >?= (fun quants =>
                collector quants l1 l2 >?= (fun quants =>
                let quants = pop_rigid quants in
                collector quants r1 r2)))
            end

          | ((|- forall (?x1 : ?a1), ?b1), (|- forall (?x2 : ?a2), ?b2)) =>
            collector quants a1 a2 >?= (fun quants =>
            let quants = add_paired_rigids x1 x2 quants in
            collector quants b1 b2 >?= (fun quants =>
            let quants = pop_rigid quants in
            Some quants))

          | ((|- ?l1 == ?r1), (|- ?l2 == ?r2)) =>
            match (l1, l2) with
              ((|- _ : ?t1), (|- _ : ?t2)) =>
                collector quants t1 t2 >?= (fun quants =>
                collector quants l1 l2 >?= (fun quants =>
                collector quants r1 r2))
            end

          | ((|- refl ?e1), (|- refl ?e2)) =>
            match (e1, e2) with
              ((|- _ : ?t1), (|- _ : ?t2)) =>
                collector quants t1 t2 >?= (fun quants =>
                collector quants e1 e2)
            end

          | _ => None
        end
      | None => None
    end


(* Given `(x1, Some v1), ..., (xn, Some vn)` apply `f` to the
   values `v1, ..., vn` and return `Some (f v1 ... vn)`.
   If any of the `Some vi` is `None`, fail by returning `None`.
*)
let apply_quants =
  let rec filter acc quants = match quants with
    | [] => Some (rev acc)
    | (_, None) :: _ => None
    | (_, Some ?v) :: ?quants => filter (v :: acc) quants
    end
  in
  fun f quants =>
  match filter [] quants with
    | None => None
    | Some ?vs => f vs
  end

(* given `pat = (f,quants,lhs)`
   where `quants` is an instantiation (usually with only non instantiated pattern variables),
   match `e` with `lhs` and apply `f` to the resulting instantiation if successful.

   `f` may be either a closure or a term with a product type.
*)
let generic_matcher pat e =
  match pat with
    | (?f, (?quants, ?lhs)) =>
      match collector (quants,[]) lhs e with
        | Some (?quants,_) =>
          apply_quants f quants
        | None => None
      end
  end

let spine h es : judgement â†’ list judgement â†’ judgement = 
  fold (fun h e => h e) h es

(* A beta hint is a term `e` whose type is a universally quantified equation
   `âˆ (x1:A1) ... (xn:An), lhs == rhs`.
   It is used by matching `lhs` against a term to be reduced to the instantiated `rhs`.

   If the instantiation of `x1, .., xn` cannot be read off `lhs` (because not all the
   `x1, ..., xn` appear in it) then the beta hint will fail later on (at the `apply_quants` stage).
*)
let process_beta =
  let rec deep quants e b = match b with
    | |- forall (?x : _), ?b =>
      deep ((x, None) :: quants) e b
    | |- ?lhs == _ => (fun lst => Some (spine e lst), (rev quants, lhs))
    end
  in
  fun e => match e with
    | |- ?e : ?b => deep [] e b
    end

(* Attempt to apply one of `betas` to a term `e`. Here `betas` is a list of beta hints previously
   processed by `process_beta`. Return `Some (âŠ¢ p : e == e')` or `None` if no hint applies. *)
let apply_beta_hint e =
  let rec fold lst =
  match lst with
    | [] => None
    | ?b :: ?rem =>
      match generic_matcher b e with
        | (Some _) as ?m => m
        | None => fold rem
      end
  end
  in
  fold betas

let add_beta_to b betas =
  let b = process_beta b in
  b :: betas

let add_beta h = add_beta_to h betas

let add_betas hs =
  fold (fun betas b => add_beta_to b betas) betas hs
