#include_once "utils.m31"

let typeof e =
  match e with ⊢ _ : ?A ⇒ A end

(* if `x : A` and `eq : A == B` return `x : B` *)
let convert x eq =
match eq with
  ⊢ _ : _ == ?t ⇒
  handle x : t with coerce x t ⇒ yield (Convertible eq) end
end

(* if `eq = (a == b : A)` and `eqt : A == B` return a witness of `(a == b : A) == (a == b : B)` *)
let convert_eq eq eqt =
match (eq, eqt) with
  | (_, ⊢ _ : ?t == ?t) ⇒ refl eq
  | (⊢ ?a == ?b, ⊢ _ : _ == ?t) ⇒
    let a' = convert a eqt
    and b' = convert b eqt in
    let eq' = a' == b' in
    match (handle congruence eq eq' with equal _ _ ⇒ yield (Some eqt) end) with
    Some ?eq ⇒ eq
    end
end

(* The term witnessing symmetry of equality. *)
let sym = λ (A : Type) (x y : A) (h : x ≡ y), handle refl x : y ≡ x with
  | equal x y ⇒
    yield (Some h)
  end

(* The term witnessing transitivity of equality *)
let tran = lambda (t : Type) (a b c : t) (eq1 : a == b) (eq2 : b == c),
  handle eq1 : a == c with
    | coerce (⊢ eq1 : ?X) (⊢ ?Y) ⇒
      handle
        match congruence X Y with
        | Some ?xi ⇒ yield (Convertible xi)
        end
      with
      | equal b c ⇒ yield (Some eq2)
      end
  end

(* Take `p : a == b` and return `refl b : a == b`. This is used to make
   witnesses of equalities small. *)
let hide_witness eq = match eq with
  ⊢ _ : ?a == ?b ⇒ match a with ⊢ _ : ?t ⇒
    handle refl b : a == b with equal b a ⇒ yield (Some (sym t a b eq)) end
  end end

(* Take `p : a == b` and return `refl a : b == a`. This is used instead
   of `sym` to keep witnesses of equality small. *)
let symmetry eq =
  match eq with
    ⊢ _ : ?a == ?b ⇒
      match a with ⊢ _ : ?t ⇒
        hide_witness (sym t a b eq)
      end
  end

(* As `symmetry` but for transitivity. *)
let transitivity eq1 eq2 =
  match (eq1, eq2) with
    | ((⊢ _ : ?a == ?b), (⊢ _ : ?b == ?c)) ⇒
      match a with ⊢ _ : ?t ⇒
        hide_witness (tran t a b c eq1 eq2)
      end
  end

let rec occurs_check imps a e =
  match occurs a e with
  | (Some _) as ?xi ⇒ xi
  | None ⇒
    (* it could still occur via imps *)
    let rec fold ctx =
      match ctx with
      | [] ⇒ None
      | ?b :: ?ctx ⇒
        match assoc_find b imps with
        | None ⇒ fold ctx
        | Some (_, _, ?r) ⇒
          match !r with
          | None ⇒ fold ctx
          | Some (|- _ : _ == ?e') ⇒
            match occurs_check imps a e' with
            | None ⇒ fold ctx
            | (Some _) as ?xi ⇒ xi
            end
          end
        end
      end
    in
    fold (context e)
  end

let rec prodify xs t =
  match xs with
    | [] => t
    | (|- ?x : ?u) :: ?xs =>
      let t = prodify xs t in
      forall (y : u), t where x = y
  end

let rec spine head es =
  match es with
    | [] => head
    | ?e :: ?es => spine (head e) es
  end

let rec lambdafy xs e =
  match xs with
  | [] => e
  | (|- ?x : ?t) :: ?xs =>
    let e = lambdafy xs e in
    lambda (y : t), e where x = y
  end

let rec spine_head e =
  match e with
  | |- ?e1 _ => spine_head e1
  | |- _ => e
  end

(* Helper functions for imps *)
let mk_imp xs T =
  let T = prodify xs T in
  assume imp : T in
  (imp, (xs, spine imp xs, ref None))

(* Check that two types are equal *)
let rec equal_ty imps A B = equal_term imps A B

(* General equality check *)
and equal_term imps e1 e2 =
  let A = typeof e1 in
  match whnf_ty imps A with
  ⊢ ?eqA : _ == ?A' ⇒
    match A' with

    | ⊢ _ == _ ⇒
      let e1' = convert e1 eqA
      and e2' = convert e2 eqA in
      match extensionality e1' e2' with
      | Some ?xi ⇒
          let delta = convert_eq (typeof xi) (symmetry eqA) in
          let xi' = convert xi delta in
            Some xi'
      end

    | ⊢ forall (_), _ ⇒
      let e1' = convert e1 eqA
      and e2' = convert e2 eqA in
      handle
        match extensionality e1' e2' with
        | Some ?xi ⇒
          let delta = convert_eq (typeof xi) (symmetry eqA) in
          let xi' = convert xi delta in
            Some xi'
        | None ⇒ None
        end
      with
        equal ?a ?b ⇒ yield (equal_term imps a b)
      end

    | _ ⇒
      match (whnf_term imps e1, whnf_term imps e2) with
        (⊢ ?eq1 : _ == ?e1', ⊢ ?eq2 : _ == ?e2') ⇒
        match equal_term_whnf imps e1' e2' with
        | Some ?xi ⇒
          Some (transitivity eq1 (transitivity xi (symmetry eq2)))
        | None ⇒ None
        end
      end

    end
  end

and equal_term_whnf imps e1 e2 =
  let by_congruence _ =
    handle
      congruence e1 e2
    with
      equal ?a ?b ⇒ yield (equal_term imps a b)
    end
  in  
  let eq_by_congruence =
    match (e1, e2) with

    | (?e, ?e) ⇒ Some (refl e1)

    | (⊢ forall (_), _, ⊢ forall (_), _) ⇒
      by_congruence ()

    | (⊢ lambda (_), _, ⊢ lambda (_), _) ⇒
      by_congruence ()

    | (⊢ _ == _, ⊢ _ == _) ⇒
      by_congruence ()

    | (⊢ refl _, ⊢ refl _) ⇒
      by_congruence ()

    | (⊢ ?h1 _, ⊢ ?h2 _) ⇒
      handle
        congruence e1 e2
      with
      | equal h1 h2 ⇒ yield (equal_term_whnf imps h1 h2)
      | equal ?x ?y ⇒ yield (equal_term imps x y)
      end

    | (_, _) ⇒ None
    end
  in
  match eq_by_congruence with
  | Some _ => eq_by_congruence
  | None =>
    (* Here we try to make one side equal to another by
       instantiating an imp *)
    match instantiate imps e1 e2 with
    | (Some _) as ?xi => xi
    | None =>
      match instantiate imps e2 e1 with
      | None => None
      | Some ?xi => Some (symmetry xi)
      end
    end
  end

(* Try to make a equal to b by instantiating an imp in a.
   This will work if a is an imp applied to suitable atoms. *)
and instantiate imps a b =
  let imp = spine_head a in
  match assoc_find imp imps with
  | None => None
  | Some (?xs, ?s, ?r) =>
    match a with
    | s => 
      (* TODO check that the context of b satisfies:
         if any current hypothesis x appears in context of b then it also appears in xs *)
      let e = lambdafy xs b in
      match occurs_check imps imp e with
      | None =>
        assume xi : imp == e in
          r := Some xi ;
          equal_term imps a b
      | Some _ => None
      end
    | _ => None
    end
  end

and whnf_ty imps A = whnf_term imps A

and whnf_term imps e =
  match e with

  | ⊢ ?h ?a ⇒
    match whnf_term imps h with

    | ⊢ ?eqH : _ == ?h' ⇒
      let zeta = (* h a == h' a at type of e *)
        handle 
          match congruence (h a) (h' a) with
          | Some (⊢ ?zeta : ?zeta_ty) ⇒
            convert zeta (convert_eq zeta_ty (natural e))
          end
        with
        | equal h h' ⇒ yield (Some eqH)
        end
      in
      match h' with
      | ⊢ (lambda (_), _) ⇒
        let e' = 
          match zeta with ⊢ _ : _ == ?e' ⇒ e' end
        in
        handle
          match reduction e' with
          | Some (⊢ ?xi : _ == ?e'') ⇒
            let theta = whnf_term imps e'' in
            transitivity zeta (transitivity xi theta)
          | None ⇒ refl e
          end
        with
        | equal ?x ?y ⇒ yield (equal_term imps x y)
        end

      | ⊢ _ ⇒ zeta
      end
    end

  | ⊢ _ ⇒
    match assoc_find e imps with
    | None ⇒ refl e
    | Some (_, _, ?r) ⇒
      match !r with
      | None ⇒ refl e
      | Some (⊢ ?xi : _ == ?e') ⇒
        let zeta  = whnf_term imps e' in
        transitivity xi zeta
      end
    end

  end

operation ? : judgement

operation resolve : judgement → judgement

let rec resolver imps e =
  let rec fold eqs e hyps =
    match hyps with
    | [] ⇒ e
    | ((⊢ _atom _) as ?a) :: ?hyps ⇒
      match assoc_find a imps with
      | Some (_, _, ?r) =>
        match !r with
        | None => fold eqs e hyps
        | Some (⊢ ?eq : _ == ?e') ⇒
          let e' = resolver imps e' in
          let e = (e where a = e') in
          fold ((eq, refl e') :: eqs) e hyps
        end
      | None ⇒ 
        match assoc_find a eqs with
        | None => fold eqs e hyps
        | Some ?xi =>
          let e = (e where a = xi) in
          fold eqs e hyps
        end
      end
    end
  in
  fold [] e (context e)

let unify_prod imps A =
  match whnf_ty imps A with
  |- ?eq : _ == ?B =>
    match B with
    | |- forall (_), _ => Some (eq, imps)
    | _ =>
      let imp = spine_head B in
      match assoc_find imp imps with
      | Some (?xs, ?s, ?r) =>
        match B with
        | s => 
          match mk_imp xs Type with
          | (_, (_, ?spineD, _)) as ?impD =>
            match mk_imp xs (spineD -> Type) with
            | (_, (_, ?spineC, _)) as ?impC =>
              let C = lambdafy xs (forall (z : spineD), spineC z) in
              assume xi : (imp == C) in
              r := Some xi;
              let imps = impD :: impC :: imps in
              let zeta = transitivity eq (whnf_ty imps B) in
              Some (zeta, imps)
            end
          end
        | _ => None
        end
      | None => None
      end
    end
  end

let unify_eq imps A =
  match whnf_ty imps A with
  |- ?eq : _ == ?B =>
    match B with
    | |- _ == _ => Some (eq, imps)
    | _ =>
      let imp = spine_head B in
      match assoc_find imp imps with
      | Some (?xs, ?s, ?r) =>
        match B with
        | s => 
          match mk_imp xs Type with
          | (_, (_, ?spineT, _)) as ?impT =>
            match (mk_imp xs spineT, mk_imp xs spineT) with
            | ((_, (_, ?spineL, _)) as ?impL, (_, (_, ?spineR, _)) as ?impR) =>
              let C = lambdafy xs (spineL == spineR) in
              assume xi : (imp == C) in
              r := Some xi;
              let imps = impT :: impL :: impR :: imps in
              let zeta = transitivity eq (whnf_ty imps B) in
              Some (zeta, imps)
            end
          end
        | _ => None
        end
      | None => None
      end
    end
  end

let implicits =
handler
  | equal ?a ?b ⇒ fun imps ⇒
    yield (equal_term imps a b) imps

  | coerce (⊢ _ : ?A) ?B ⇒ fun imps ⇒
    match equal_ty imps A B with
    | Some ?xi ⇒ yield (Convertible xi) imps
    | None ⇒ yield NotCoercible imps
    end

  | coerce_fun (|-_ : ?A) => fun imps =>
    match unify_prod imps A with
    | Some (?eq, ?imps) => yield (Convertible eq) imps
    | None => yield NotCoercible imps
    end

  | as_prod ?A => fun imps =>
    match unify_prod imps A with
    | Some (?eq, ?imps) => yield (Some eq) imps
    | None => yield None imps
    end

  | as_eq ?A => fun imps =>
    match unify_eq imps A with
    | Some (?eq, ?imps) => yield (Some eq) imps
    | None => yield None imps
    end

  | ? : Some ?A ⇒ 
    let xs = rev hypotheses in
    let A' = prodify xs A in
    assume imp : A' in
    fun imps ⇒
      let s = spine imp xs in
      let imps = (imp, (xs, s, ref None)) :: imps in
      yield s imps

  | resolve ?e ⇒ fun imps ⇒
    yield (resolver imps e) imps

  | val ?v ⇒ fun imps ⇒ v

  | finally ?f ⇒ f []
end
